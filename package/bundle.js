(()=>{"use strict";var e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Mips32Compiler:()=>rt});class s{static isNumeric(e){return e>="0"&&e<="9"}static isAlpha(e){return/^[a-zA-Z]$/.test(e)}static isOperator(e){return["+","-","*","/","%","<",">","|","^","&"].includes(e)}static isSeparator(e){return" "==e}static isCommaSeparator(e){return","==e}static isAssignationEnding(e){return";"==e}static pruneSpacesAndNewlines(e,t){for(;t<e.length&&s.isEmptySpaceOrNewLine(e[t]);)t++;return t}static isEmptySpaceOrNewLine(e){return" "==e||"\n"==e||"\t"==e||"\t\n"==e}}const i=s;class r{static isValid(e){return!(!e||!e.length)&&(i.isOperator(e[0])||"=="==e||"!="==e||"||"==e||"&&"==e||"<="==e||">="==e)}static chomp(e,t){if(!e||!e.length)return L.invalid();let s=i.pruneSpacesAndNewlines(e,t);if(e.length-s>=2){let t=["==","!=","||","&&","<=",">="];for(let i=0,n=t.length;i<n;i++)if(`${e[s]}${e[s+1]}`==t[i])return new L(t[i],s+2,r)}return i.isOperator(e[s])?new L(e[s],s+1,r):L.invalid()}static chompEqual(e,t){return t=i.pruneSpacesAndNewlines(e,t),!e||t>=e.length||"="!=e[t]?L.invalid():new L("=",t+1,r)}static chompOpenParanth(e,t){return(t=i.pruneSpacesAndNewlines(e,t))>=e.length||"("!=e[t]?L.invalid():new L("(",t+1,r)}static chompCloseParanth(e,t){return(t=i.pruneSpacesAndNewlines(e,t))>=e.length||")"!=e[t]?L.invalid():new L(")",t+1,r)}static chompOpenBracket(e,t){return(t=i.pruneSpacesAndNewlines(e,t))>=e.length||"{"!=e[t]?L.invalid():new L("{",t+1,r)}static chompCloseBracket(e,t){return(t=i.pruneSpacesAndNewlines(e,t))>=e.length||"}"!=e[t]?L.invalid():new L("}",t+1,r)}}const n=r;class h{static isValid(e){for(let t=0,s=e.length;t<s;t++)if(!i.isNumeric(e[t]))return!1;return!0}static chomp(e,t){if(!e||!e.length)return L.invalid();let s=i.pruneSpacesAndNewlines(e,t),r="";for(;s<e.length&&i.isNumeric(e[s]);)r+=e[s++];return r.length?new L(r,s,h):L.invalid()}}const o=h;class a{static isValid(e){if(!e.length)return!1;if(i.isNumeric(e[0]))return!1;for(let t=0,s=e.length;t<s;t++)if(!i.isAlpha(e[t])&&!i.isNumeric(e[t])&&"_"!=e[t])return!1;return!0}static isKeyword(e){return!!["auto","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","goto","if","int","long","register","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","volatile","while"].includes(e)}static chomp(e,t){if(!e||!e.length||i.isNumeric(e[t]))return L.invalid();let s=i.pruneSpacesAndNewlines(e,t),r="";for(;s<e.length&&(i.isAlpha(e[s])||i.isNumeric(e[s])||"_"==e[s]);)r+=e[s++];return r.length?a.isKeyword(r)?L.invalid():new L(r,s,a):L.invalid()}}const l=a;class c{static keyWords(){return["int","char"]}}class u{static chomp(e,t){let s=u.chompKeywordsInitialization(e,t);if(s.isInvalid())return L.invalid();if((t=s.index)>=e.length||!i.isSeparator(e[t]))return L.invalid();t++;let r=l.chomp(e,t);if(r.isInvalid())return L.invalid();t=r.index;let n=new L(null,t,u);return n.childrenChomps=[s,r],n}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=c.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new L(s[i],t+s[i].length,c);return L.invalid()}}const d=1,g=2,p=4,f=5,m=6,b=7,k=8,R=9,S=10,I=11;class v{constructor(e,t){this.buffer=e,this.type=t}static clean(){return new v(null,f)}isClean(){return this.type==f}toString(){return"Error"}}class w{static chomp(e,t,s=!0){let r=w.chompDeclaration(e,t);if(t=r.index,s){if(t=i.pruneSpacesAndNewlines(e,t),!i.isAssignationEnding(e[t]))return L.invalid();r.index++}return r}static chompDeclaration(e,t){let s=w.chompInitializedVariable(e,t);if(s.isInvalid())return L.invalid();t=s.index;let i=z.chomp(e,t);if(i.isInvalid())return s;t=i.index;let r=new L("",t,w,!0);return r.childrenChomps=[s,i],r}static chompDeclarator(e,t){let s=G.chomp(e,t);if(!s.isInvalid())return s;let i=l.chomp(e,t);return i.isInvalid()?L.invalid():i}static chompInitializedVariable(e,t){let s=w.chompDeclarator(e,t);t=s.index;let i=n.chompEqual(e,t);return i.isInvalid()?L.invalid():(t=i.index,s.index=t,s)}static toString(e){let t="";const s=e.childrenChomps[0];switch(s.type){case l:t+=s.buffer;break;case G:t+=`*${s.childrenChomps[0].toString()}`}return t+="=",t+=e.childrenChomps[1].toString(),t+=";",t}static isAssignerDefined(e,t){switch(e.type){case l:return t.isVariableDefined(e.buffer);case G:return z.checkStackInitialization(e.childrenChomps[0],t)}return!1}static findUnassignedVariables(e,t){let s=e.childrenChomps,i=s[0],r=s[1],n=[];if(w.isAssignerDefined(i,t)||n.push(i),n.length)return new v(null,d);let h=z.checkStackInitialization(r,t);return h.isClean()?v.clean():h}}class A{static searchChompByType(e,t){let s=[];return A.searchChompByType_t(e,t,s),s}static chompToDictionary(e){const t={};return Object.keys(e).forEach((s=>{t[s]=e[s]})),t}static searchChompByType_t(e,t,s){let i=A.chompToDictionary(e),r=!0;for(const[e,s]of Object.entries(t))if(e in i&&s!=i[e]){r=!1;break}r&&s.push(e);let n=e.childrenChomps;for(let e=0,i=n.length;e<i;e++)A.searchChompByType_t(n[e],t,s)}}class y{static keyWords(){return["int","char"]}}class T{}class C{static isValid(e){let t=0,s=C.chompDeclarationHeader(e,t);if(s.isInvalid())return!1;for(t=s.index;t<e.length;){let s=C.chompDeclaration(e,t);if(s.isInvalid())break;t=s.index,i.isCommaSeparator(e[t])&&t++}return!!i.isAssignationEnding(e[t])}static chomp(e,t){let s=[],r=C.chompDeclarationHeader(e,t);if(r.isInvalid())return L.invalid();for(s.push(r),t=r.index;t<e.length;){let r=C.chompDeclaration(e,t);if(r.isInvalid())break;s.push(r),t=r.index,t=i.pruneSpacesAndNewlines(e,t),i.isCommaSeparator(e[t])&&t++}if(t=i.pruneSpacesAndNewlines(e,t),!i.isAssignationEnding(e[t]))return L.invalid();let n=new L(null,t+1,C,!0);return n.childrenChomps=s,n}static chompDeclaration(e,t){let s=C.chompInitializedVariable(e,t);if(s.isInvalid())return L.invalid();t=s.index;let i=z.chomp(e,t);if(i.isInvalid()){let e=new L(null,t,T,!0);return e.childrenChomps=[s],e}t=i.index;let r=new L(null,t,T,!0);return r.childrenChomps=[s,i],r}static chompDeclarationHeader(e,t){let s=C.chompKeywordsInitialization(e,t);return s.isInvalid()?s:(t=s.index,i.isSeparator(e[t])?(s.index=t+1,s):L.invalid())}static chompInitializedVariable(e,t){let s=l.chomp(e,t);if(s.isInvalid())return L.invalid();t=s.index;let i=n.chompEqual(e,t);return i.isInvalid()?s:(t=i.index,new L(s.buffer,t,l))}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=y.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new L(s[i],t+s[i].length,y);return L.invalid()}static displayComponent(e){let t="",s=e.childrenChomps;t+=s[0].buffer+"=";for(let e=1,i=s.length;e<i;e++)s[e].type!=z?t+=s[e].buffer:t+=s[e].toString();return t}static display(e){if(e.isInvalid())return"Invalid!";let t=[];t.push(e.childrenChomps[0].buffer);let s=e.childrenChomps;for(let e=1,i=s.length;e<i;e++)t.push(C.displayComponent(s[e]));return t.join(" -> ")}static initializeVariable(e,t){let s=A.searchChompByType(e,{type:l});for(let e=0,i=s.length;e<i;e++)t.push(s[e].buffer)}static hasVariableAlreadyBeenDefined(e,t){let s=A.searchChompByType(e,{type:l});for(let e=0,i=s.length;e<i;e++)if(t.isVariableDefined(s[e].buffer))return!0;return!1}static addToStackAndVerify(e,t){let s=A.searchChompByType(e,{type:T});for(let e=0,i=s.length;e<i;e++){let i=s[e].childrenChomps,r=i[0];if(C.hasVariableAlreadyBeenDefined(r,t))return new v([r.buffer],g);if(C.initializeVariable(r,t),i.length>1){let e=i[1],s=z.checkStackInitialization(e,t);if(!s.isClean())return s}}return v.clean()}}class _{static keyWords(){return["while","for"]}}class ${static chomp(e,t,s=!1){let i=$.chompKeywordsInitialization(e,t);return i.isInvalid()?L.invalid():(t=i.index,"while"==i.buffer?$.chompWhileBlock(e,t,s):"for"==i.buffer?$.chompForBlock(e,t,s):L.invalid())}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=_.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new L(s[i],t+s[i].length,_);return L.invalid()}static chompWhileBlock(e,t,s){let i=n.chompOpenParanth(e,t);if(i.isInvalid())return L.invalid();t=i.index;let r=z.chomp(e,t);if(r.isInvalid())return L.invalid();t=r.index;let h=n.chompCloseParanth(e,t);if(h.isInvalid())return L.invalid();t=h.index;let o=N.chomp(e,t,s);if(o.isInvalid())return L.invalid();t=o.index;let a=new L("while",t,$);return a.childrenChomps=[r,o],a}static chompForBlock(e,t,s){let r=n.chompOpenParanth(e,t);if(r.isInvalid())return L.invalid();t=r.index;let h=$.chompForInitialization(e,t);if(h.isInvalid())return L.invalid();t=h.index;let o=z.chomp(e,t);if(o.isInvalid())return L.invalid();if((t=o.index)>=e.length||!i.isAssignationEnding(e[t]))return L.invalid();t++;let a=w.chomp(e,t,!1);if(a.isInvalid())return L.invalid();t=a.index;let l=n.chompCloseParanth(e,t);if(l.isInvalid())return L.invalid();t=l.index;let c=N.chomp(e,t,s);if(c.isInvalid())return L.invalid();t=c.index;let u=new L("for",t,$);return u.childrenChomps=[h,o,a,c],u}static chompForInitialization(e,t){let s=[w.chomp,C.chomp];for(let i=0;i<s.length;i++){let r=s[i](e,t);if(!r.isInvalid())return r}return L.invalid()}static addToStackAndVerify_While(e,t){const s=e.childrenChomps;let i=s[0],r=z.checkStackInitialization(i,t);if(!r.isClean())return r;if(s.length<2)return v.clean();let n=s[1];return N.addToStackAndVerify(n,t)}static addToStackAndVerify_For(e,t){const s=e.childrenChomps;let i=s[0],r=s[1],n=s[2];switch(i.type){case w:{let e=w.findUnassignedVariables(i,t);if(!e.isClean())return e;break}case C:{let e=C.addToStackAndVerify(i,t);if(!e.isClean())return e;break}}const h=z.checkStackInitialization(r,t);if(!h.isClean())return h;const o=z.checkStackInitialization(n,t);if(!o.isClean())return o;if(s.length<=3)return v.clean();const a=s[3];return N.addToStackAndVerify(a,t)}static addToStackAndVerify(e,t){switch(e.buffer){case"while":return $.addToStackAndVerify_While(e,t);case"for":{t.freeze();let s=$.addToStackAndVerify_For(e,t);return t.pop(),s}}return v.clean()}}class x{static keyWords(){return["if"]}}class E{static chomp(e,t,s=!1){let i=E.chompKeywordsInitialization(e,t);if(i.isInvalid())return L.invalid();t=i.index;let r=n.chompOpenParanth(e,t);if(r.isInvalid())return L.invalid();t=r.index;let h=z.chomp(e,t);if(h.isInvalid())return L.invalid();t=h.index;let o=n.chompCloseParanth(e,t);if(o.isInvalid())return L.invalid();t=o.index;let a=N.chomp(e,t,s);if(a.isInvalid())return L.invalid();t=a.index;let l=new L(null,t,E);return l.childrenChomps=[h,a],l}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=x.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new L(s[i],t+s[i].length,x);return L.invalid()}static addToStackAndVerify(e,t){let s=e.childrenChomps;const i=s[0],r=s[1];let n=z.checkStackInitialization(i,t);return n.isClean()?N.addToStackAndVerify(r,t):n}}class N{static chomp(e,t,s=!1){let i=n.chompOpenBracket(e,t);if(i.isInvalid())return L.invalid();t=i.index;let r=N.chompBlock(e,t,s);t=r.index;let h=n.chompCloseBracket(e,t);if(h.isInvalid())return L.invalid();t=h.index;let o=new L(null,t,N);return o.childrenChomps=r.childrenChomps,o}static expressionChompWithLineTerminator(e,t){let s=z.chomp(e,t);return s.isInvalid()||(t=s.index)>=e.index||!i.isAssignationEnding(e[t])?L.invalid():(s.index++,s)}static chompBlock(e,t,s){let i=[w.chomp,C.chomp,(e,t)=>N.chomp(e,t,s),(e,t)=>$.chomp(e,t,s),(e,t)=>E.chomp(e,t,s)];s&&i.push(M.chomp),i.push(N.expressionChompWithLineTerminator);let r=[];for(;t<e.length;){let s=!1;for(let n=0;n<i.length;n++){let h=i[n](e,t);if(!h.isInvalid()){t=h.index,s=!0,r.push(h);break}}if(!s)break}let n=new L(null,t,N);return n.childrenChomps=r,n}static addToStackAndVerify_t(e,t){let s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++){let i=s[e];switch(i.type){case w:{let e=w.findUnassignedVariables(i,t);if(!e.isClean())return e;break}case C:{let e=C.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case N:{let e=N.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case $:{let e=$.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case E:{let e=E.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case M:{let e=M.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case z:{let e=z.checkStackInitialization(i,t);if(!e.isClean())return e;break}}}return v.clean()}static addToStackAndVerify(e,t){t.freeze();let s=N.addToStackAndVerify_t(e,t);return t.pop(),s}}class D{static keyWords(){return["int","void","char"]}}class V{static findUnassignedVariables(e,t){let s=e.childrenChomps[1].childrenChomps;for(let e=0,i=s.length;e<i;e++){let i=z.checkStackInitialization(s[e],t);if(!i.isClean())return i}return v.clean()}static doesMethodHaveAllTheParametersPresent(e,t){let s=e.childrenChomps,i=s[0].buffer,r=s[1].childrenChomps;const n=t.getArgsFromMethodName(i);return!n||n.length!=r.length}}class B{}class M{static keyWords(){return["return"]}static chomp(e,t){let s=M.chompKeywordsInitialization(e,t);if(s.isInvalid())return L.invalid();if((t=s.index)>=e.length||!i.isSeparator(e[t]))return L.invalid();t++;let r=z.chomp(e,t);if(r.isInvalid())return L.invalid();if(t=r.index,(t=i.pruneSpacesAndNewlines(e,t))>=e.length||!i.isAssignationEnding(e[t]))return L.invalid();t++;let n=new L(null,t,M);return n.childrenChomps=[r],n}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=M.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new L(s[i],t+s[i].length,D);return L.invalid()}static addToStackAndVerify(e,t){const s=e.childrenChomps[0];return z.checkStackInitialization(s,t)}}class O{static chompDeclaration(e,t){let s=O.methodHeaderDeclaration(e,t);if(s.isInvalid())return L.invalid();t=s.index;let i=n.chompOpenParanth(e,t);if(i.isInvalid())return L.invalid();t=i.index;let r=O.chompMethodDeclarationsAnthetParams(e,t);if(r.isInvalid())return L.invalid();t=r.index;let h=n.chompCloseParanth(e,t);if(h.isInvalid())return L.invalid();t=h.index;let o=N.chomp(e,t,!0);if(o.isInvalid())return L.invalid();t=o.index;let a=new L(s.buffer,t,O);return a.childrenChomps=[s,r,o],a}static chompMethodCall(e,t){let s=l.chomp(e,t);if(s.isInvalid())return L.invalid();t=s.index;let i=n.chompOpenParanth(e,t);if(i.isInvalid())return L.invalid();t=i.index;let r=O.chompMethodParameters(e,t);if(r.isInvalid())return L.invalid();t=r.index;let h=n.chompCloseParanth(e,t);if(h.isInvalid())return L.invalid();t=h.index;let o=new L(null,t,V);return o.childrenChomps=[s,r],o}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=D.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new L(s[i],t+s[i].length,D);return L.invalid()}static chompMethodParameters(e,t){let s=[],r=!1;for(;t<e.length;){let n=z.chomp(e,t),h=n.isInvalid();if(!r&&h)return O.arrayToChomp(s,t);if(h)return L.invalid();if(r=!0,t=n.index,s.push(n),(t=i.pruneSpacesAndNewlines(e,t))>=e.length||!i.isCommaSeparator(e[t]))return O.arrayToChomp(s,t);t++}return O.arrayToChomp(s,t)}static methodHeaderDeclaration(e,t){let s=O.chompKeywordsInitialization(e,t);if(s.isInvalid())return L.invalid();if((t=s.index)>=e.length||!i.isSeparator(e[t]))return L.invalid();t++;let r=l.chomp(e,t);if(r.isInvalid())return L.invalid();t=r.index;let n=new L(r.buffer,t,B);return n.childrenChomps=[s,r],n}static arrayToChomp(e,t){let s=new L(null,t);return s.childrenChomps=e,s}static chompMethodDeclarationsAnthetParams(e,t){let s=[],r=!1;for(;t<e.length;){let n=u.chomp(e,t);if(!r&&n.isInvalid())return O.arrayToChomp(s,t);if(s.push(n),r=!0,(t=n.index)>=e.length||!i.isCommaSeparator(e[t]))return O.arrayToChomp(s,t);t++}return O.arrayToChomp(s,t)}static searchMethodByName(e,t){return A.searchChompByType(e,{buffer:t,type:O})}static searchAllMethods(e){return A.searchChompByType(e,{type:O})}static pushMethodParams(e,t,s){const i=t.childrenChomps;let r=[];for(let e=0,t=i.length;e<t;e++){const t=i[e].childrenChomps[0],s=i[e].childrenChomps[1];r.push({type:t,name:s})}s.pushMethod(e,r)}static checkParamsAndPush(e,t){const s=e.childrenChomps;let i=[];for(let e=0,r=s.length;e<r;e++){const r=s[e].childrenChomps[1].buffer;t.isVariableDefined(r)&&i.push(r)}return i}static pushParams(e,t){const s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++){const i=s[e].childrenChomps[1];t.push(i.buffer)}}static doesReturnNeedsToBe(e,t){const s=A.searchChompByType(t,{type:M});return("void"!=e||!s.length)&&!("void"!=e&&!s.length)}static addToStackAndVerify(e,t){let s=e.childrenChomps;const i=s[0],r=s[1],n=s[2],h=i.childrenChomps[1],o=i.childrenChomps[0].buffer;if(t.isMethodDefined(h.buffer)||t.isVariableDefined(h.buffer))return new v([h.buffer],g);let a=O.checkParamsAndPush(r,t);if(a.length)return new v(a,g);if(!O.doesReturnNeedsToBe(o,n))return new v(null,m);O.pushMethodParams(h.buffer,r,t),t.freeze(),O.pushParams(r,t);let l=N.addToStackAndVerify(n,t);return l.isClean()?(t.pop(),v.clean()):l}}class P{static isValid(e){let t=[0],s=[];if(P.denominator_Chomp(e,t,s).isInvalid())return!1;for(;t<e.length;){if(P.operator_Chomp(e,t,s).isInvalid())return!1;if(P.denominator_Chomp(e,t,s).isInvalid())return!1}return!0}static operator_Chomp(e,t,s){let i=n.chomp(e,t[0]);return i.isInvalid()?L.invalid():(s.push(i),t[0]=i.index,i)}static denominator_Chomp(e,t,s){let i=P.chompDenominator(e,t[0]);if(i.isInvalid()){let i=[t[0]],r=P.chomp_ParanthesisData(e,i[0]);return r.isInvalid()||(s.push(r),t[0]=r.index),r}return s.push(i),t[0]=i.index,i}static chompFromArray(e,t){let s=new L(null,t[0],P,!0);return s.childrenChomps=e,s}static chompSearch_t(e,t){let s=[t],i=[];if(P.denominator_Chomp(e,s,i).isInvalid())return L.invalid();for(;s<e.length;){if(P.operator_Chomp(e,s,i).isInvalid())return P.chompFromArray(i,s);if(P.denominator_Chomp(e,s,i).isInvalid())return L.invalid()}return P.chompFromArray(i,s)}static chomp(e,t){for(let s=e.length-1;s>=t;s--){let i=P.chompSearch_t(e.substring(t,s+1),0);if(!i.isInvalid())return i.index+=t,i}return L.invalid()}static chomp_ParanthesisData(e,t){let s=n.chompOpenParanth(e,t);if(s.isInvalid())return L.invalid();t=s.index;let i=P.chompSearch_t(e,t);if(i.isInvalid())return L.invalid();t=i.index;let r=n.chompCloseParanth(e,t);return r.isInvalid()?L.invalid():(t=r.index,P.chompFromArray(i.childrenChomps,[t]))}static chompDenominator(e,t){let s=[O.chompMethodCall,G.chomp,o.chomp,l.chomp];for(let i=0,r=s.length;i<r;i++){let r=s[i](e,t);if(!r.isInvalid())return r}return L.invalid()}static checkStackInitialization_t(e,t){const s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++)switch(s[e].type){case l:if(!t.isVariableDefined(s[e].buffer))return new v([s[e].buffer],d);break;case G:{let i=G.findUnassignedVariables(s[e],t);if(!i.isClean())return i;break}case P:P.checkStackInitialization_t(s[e],t);break;case V:{let i=V.findUnassignedVariables(s[e],t);if(!i.isClean())return i;if(V.doesMethodHaveAllTheParametersPresent(s[e],t))return new v("Wrong number of arguments of method!",p);break}}return v.clean()}static checkStackInitialization(e,t){return P.checkStackInitialization_t(e,t)}}const z=P;class G{static chomp(e,t){if(!e||t>=e.length)return L.invalid();if("*"!=e[t=i.pruneSpacesAndNewlines(e,t)])return L.invalid();t++;let s=l.chomp(e,t);if(!s.isInvalid()){t=s.index;let e=new L(null,t,G);return e.childrenChomps=[z.chomp(s.buffer,0)],e}let r=z.chomp_ParanthesisData(e,t);if(r.isInvalid())return L.invalid();t=r.index;let n=new L(null,t,G);return n.childrenChomps=[r],n}static findUnassignedVariables(e,t){const s=e.childrenChomps[0];return z.checkStackInitialization(s,t)}}class F{constructor(e,t,s=null,i=!1,r=!1){this.buffer=e,this.index=t,this.invalid=r,this.type=s,this.childrenChomps=[],this.isParent=i,this.expressionTree=null}static invalid(){return new F(-1,-1,null,!1,!0)}pushChild(e){this.childrenChomps.push(e)}isInvalid(){return this.invalid}toString(e=0){if(this.isParent){let t="";for(let s=0,i=this.childrenChomps.length;s<i;s++){t+=this.childrenChomps[s].toString(e+1)}return e?`(${t})`:t}return this.type===G?`*${this.childrenChomps[0].toString()}`:this.buffer}}const L=F;class U{constructor(){this.index=[0],this.variables=[],this.methods=[]}push(e){this.variables.push({type:"variable",value:e})}pushMethod(e,t){this.methods.push({type:"method",value:e,params:t})}getArgsFromMethodName(e){for(let t=0,s=this.methods.length;t<s;t++)if("method"==this.methods[t].type&&e==this.methods[t].value)return this.methods[t].params;return null}isMethodDefined(e){for(let t=0,s=this.methods.length;t<s;t++)if("method"==this.methods[t].type&&e==this.methods[t].value)return!0;return!1}isVariableDefined(e){for(let t=0,s=this.variables.length;t<s;t++)if("variable"==this.variables[t].type&&e==this.variables[t].value)return!0;return!1}top(){return this.variables[this.variables.length-1].value}freeze(){this.index.push(this.variables.length)}pop(){if(this.index.length){for(let e=this.variables.length-1;e>=this.index[this.index.length-1];e--)this.variables.pop();this.index.pop()}}}class K{static methods(e){return`${K.getElementAt()}${K.storeElement()}${K.storePrint(e)}${K.bytePrint(e)}`}static getElementAt(){return"int getElement(int buffer,int pos){return *(buffer+pos*4);}"}static storeElement(){return"int setElement(int buffer,int pos,int element){*(buffer+pos*4)=element;return 0;}"}static bytePrint(e){return`\n    int __digitCount(int n) {\n      int total = 0;\n      while(n) {\n        n = n / 10;\n        total = total + 1;\n      }\n\n      return total;\n    }\n\n    int pushCharacter(int character) {\n      int stdoutBuffer = ${e};\n      int currentOffset = *(stdoutBuffer - 4);\n      *(stdoutBuffer + currentOffset) = character;\n      *(stdoutBuffer - 4) = currentOffset + 1;\n      return 0;\n    }\n    \n    int printNumber_t(int element){\n      if(element == 0) {\n        return 0;\n      }\n      printNumber_t(element / 10);\n      pushCharacter(element % 10 + 48);\n      return 0;\n    }\n\n    int printChar(int element){\n      return pushCharacter(element);\n    }\n    \n    int printNumber(int element){\n      if(element < 0) {\n        element = 0 - element;\n        printChar(45);\n        return printNumber_t(element);\n      }\n      if(element == 0) {\n        printChar(48);\n      }\n      return printNumber_t(element);\n    }\n    `}static storePrint(e){return`int printLine(int element){int startingPointer=${e};int size=*(startingPointer-4);*(startingPointer+size)=element;*(startingPointer-4)=size+4;return 0;}`}}class W{constructor(e,t=[],s=!0,i=65536){this.code=s?`${K.methods(i)}${e}`:e,this.errors=t}chomp(){let e=this._chomp(this.code,0);return e.isInvalid()?(this.errors.push(new v(null,I)),L.invalid()):this.validateChomp(e)?e:L.invalid()}validateChomp(e){let t=O.searchMethodByName(e,"main");return t.length?t.length>1?(this.errors.push(new v(null,S)),!1):!!this.validateMethodsUniqueness(e)&&(!!this.validateVariableNonKeywords(e)&&!!this.validateStackVariables(e)):(this.errors.push(new v(null,R)),!1)}validateVariableNonKeywords(e){let t=A.searchChompByType(e,{type:l});const s=["auto","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","goto","if","int","long","register","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","volatile","while"];for(let e=0,i=t.length;e<i;e++)if(s.includes(t[e].buffer))return this.errors.push(new v(t[e].buffer,k)),!1;return!0}validateMethodsUniqueness(e){let t=O.searchAllMethods(e),s={};for(let e=0,i=t.length;e<i;e++)if(t[e].buffer in s||(s[t[e].buffer]=0),s[t[e].buffer]++,s[t[e].buffer]>1)return this.errors.push(new v(t[e].buffer,b)),!1;return!0}validateStackVariables(e){return this.validateStackVariables_t(e,new U)}validateStackVariables_t(e,t){let s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++){const i=s[e];switch(i.type){case w:{const e=w.findUnassignedVariables(i,t);if(!e.isClean())return this.errors.push(e),!1;break}case C:{const e=C.addToStackAndVerify(i,t);if(!e.isClean())return this.errors.push(e),!1;break}case O:{const e=O.addToStackAndVerify(i,t);if(!e.isClean())return this.errors.push(e),!1;break}}}return!0}_chomp(e,t){let s=[O.chompDeclaration,w.chomp,C.chomp],r=[];for(;t<e.length;){let i=!1;for(let n=0,h=s.length;n<h;n++){let h=s[n](e,t);if(!h.isInvalid()){r.push(h),i=!0,t=h.index;break}}if(!i)break}if((t=i.pruneSpacesAndNewlines(e,t))<e.length)return L.invalid();let n=new L(null,t,W);return n.childrenChomps=r,n}}const H=1,j=2;let J=65536;class q{constructor(e){this.instructionArray=e,this.register={},this.initialStackPointer=524288,this.stackPointer=this.initialStackPointer,this.memory=new Array(1048576).fill(0),this.addresses={},this.outputBuffer="",this.pc=0,this.instructionCounter={},this.saveLabelAddresses()}getStdoutResponse(){let e=[];for(let t=0,s=this.getNumberAtAddress(this.memory,65532);t<s;t+=4)e.push(this.getNumberAtAddress(this.memory,J+t));return e.join("\n")}getRawStdoutBuffer(){const e=this.getNumberAtAddress(this.memory,65532);let t="";for(let s=0;s<e;s++)t+=String.fromCharCode(this.memory[s+J]);return t}get32BitNumberAtAddress(e){return this.getNumberAtAddress(this.memory,e)}saveRegValue(e,t){let s=t.toString(),i=e.toString();s in this.register&&(this.register[i]=this.register[s])}saveLabelAddresses(){for(let e=0,t=this.instructionArray.length;e<t;e++){const t=this.instructionArray[e];t instanceof be&&(this.addresses[t.label]=e)}}currentStackPointer(){return this.stackPointer}getRegValue(e){const t=e.toString();return t in this.register?parseInt(this.register[t]):0}printPointerBytes(e){let t=[];for(let s=0;s<e;s++)t.push(this.memory[this.stackPointer+s]);return t.join(" ")}positiveNumberToByteArray(e){const t=[0,0,0,0];return t[0]=255&e,t[1]=e>>8&255,t[2]=e>>16&255,t[3]=e>>24&255,t}negativeNumberToByteArray(e){const t=2**32+e;return this.positiveNumberToByteArray(t)}numberToByteArray(e){return e>=0?this.positiveNumberToByteArray(e):this.negativeNumberToByteArray(e)}saveRegInStack(e,t){let s=this.numberToByteArray(this.getRegValue(t)),i=parseInt(e);for(let e=0,t=s.length;e<t;e++)this.memory[this.stackPointer-i+e]=s[e]}saveRegInMem(e,t){let s=this.numberToByteArray(this.getRegValue(t)),i=parseInt(e);for(let e=0,t=s.length;e<t;e++)this.memory[i+e]=s[e]}get32ByteInteger(e){return e<2**31?e:-(2**32-e)}getNumberAtAddress(e,t,s=H){switch(s){case H:{let s=0,i=1;for(let r=0;r<4;r++)s+=e[t+r]*i,i*=256;return this.get32ByteInteger(s)}case j:return e[t]}return 0}saveMemInReg(e,t){this.register[t.toString()]=this.getNumberAtAddress(this.memory,parseInt(e))}saveStackInReg(e,t){this.register[t]=this.getNumberAtAddress(this.memory,this.stackPointer-parseInt(e))}saveRegMemInReg(e,t){this.register[t.toString()]=this.getNumberAtAddress(this.memory,parseInt(this.register[e.toString()]))}saveRegInMemReg(e,t){let s=this.numberToByteArray(this.getRegValue(e)),i=this.getRegValue(t);for(let e=0,t=s.length;e<t;e++)this.memory[i+e]=s[e]}numberFromPointer(e){return this.getNumberAtAddress(this.memory,e)}runMov(e){switch(e.type){case X.REG_TO_REG:this.saveRegValue(e.dst,e.src);break;case X.REG_TO_STACK:this.saveRegInStack(e.dst,e.src);break;case X.NUMBER_TO_REG:this.register[e.dst.toString()]=parseInt(e.src);break;case X.REG_TO_MEM:this.saveRegInMem(e.dst,e.src);break;case X.MEM_TO_REG:this.saveMemInReg(e.src,e.dst);break;case X.STACK_TO_REG:this.saveStackInReg(e.src,e.dst);break;case X.REG_MEM_TO_REG:this.saveRegMemInReg(e.src,e.dst);break;case X.REG_TO_MEM_REG:this.saveRegInMemReg(e.src,e.dst)}}runPush(e){this.saveRegInStack(0,e.register),this.stackPointer+=4}runPop(e){this.stackPointer-=parseInt(e.bytes)}jumpAtRegisterLabel(e){this.pc=this.getRegValue(e)-1}runJump(e){switch(e.type){case ke.LABEL:this.pc=this.addresses[e.value];break;case ke.REGISTER:this.jumpAtRegisterLabel(e.value)}}runAdd(e){this.register[e.dst.toString()]=this.getRegValue(e.b)+this.getRegValue(e.c)}runMul(e){this.register[e.dst.toString()]=this.getRegValue(e.b)*this.getRegValue(e.c)}runSub(e){this.register[e.dst.toString()]=this.getRegValue(e.b)-this.getRegValue(e.c)}runMul(e){this.register[e.dst.toString()]=this.getRegValue(e.b)*this.getRegValue(e.c)}runDivAndMod(e){this.register.HI=this.getRegValue(e.a)%this.getRegValue(e.b),this.register.LO=Math.floor(this.getRegValue(e.a)/this.getRegValue(e.b))}runPrp(e){this.register[e.reg.toString()]=this.pc+e.offset}booleanToNumber(e){return e?1:0}runCmp(e){this.register._setGe=this.booleanToNumber(this.getRegValue(e.regA)>=this.getRegValue(e.regB)),this.register._setE=this.booleanToNumber(this.getRegValue(e.regA)==this.getRegValue(e.regB)),this.register._setNe=this.booleanToNumber(this.getRegValue(e.regA)!=this.getRegValue(e.regB)),this.register._setLe=this.booleanToNumber(this.getRegValue(e.regA)<=this.getRegValue(e.regB)),this.register._setNz=this.booleanToNumber(this.getRegValue(e.regA)&&this.getRegValue(e.regB)),this.register.CF=this.booleanToNumber(this.getRegValue(e.regA)<this.getRegValue(e.regB)),this.register.CT=this.booleanToNumber(this.getRegValue(e.regA)>this.getRegValue(e.regB))}setGe(e){this.register[e.regA.toString()]=this.register._setGe}setE(e){this.register[e.regA.toString()]=this.register._setE}setNe(e){this.register[e.regA.toString()]=this.register._setNe}setNz(e){this.register[e.regA.toString()]=this.register._setNz}setLe(e){this.register[e.regA.toString()]=this.register._setLe}setTest(e){this.register.zero_reg=this.booleanToNumber(this.getRegValue(e.regA)&&this.getRegValue(e.regB))}setJz(e){"zero_reg"in this.register&&!this.register.zero_reg&&(this.pc=this.addresses[e.label])}setOr(e){this.register.or_reg=this.booleanToNumber(this.getRegValue(e.regA)||this.getRegValue(e.regB))}setDor(e){this.register[e.reg.toString()]=this.register.or_reg}setPrint(e){switch(e.type){case ve.REGISTER:this.outputBuffer+=this.getRegValue(e.value);break;case ve.MEMORY:this.outputBuffer+=this.numberFromPointer(parseInt(e.value)+this.initialStackPointer)}}addInstructionToStatistics(e){const t=e.constructor.name;t in this.instructionCounter||(this.instructionCounter[t]=0),this.instructionCounter[t]++}runInstruction(e){e instanceof ee&&this.runMov(e),e instanceof re&&this.runPush(e),e instanceof oe&&this.runPop(e),e instanceof Re&&this.runJump(e),e instanceof te&&this.runAdd(e),e instanceof Se&&this.runDivAndMod(e),e instanceof se&&this.runSub(e),e instanceof ie&&this.runMul(e),e instanceof Ie&&this.runPrp(e),e instanceof ae&&this.runCmp(e),e instanceof pe&&this.setGe(e),e instanceof ce&&this.setE(e),e instanceof le&&this.setNe(e),e instanceof de&&this.setNz(e),e instanceof fe&&this.setLe(e),e instanceof ue&&this.setTest(e),e instanceof me&&this.setJz(e),e instanceof we&&this.setPrint(e),e instanceof ge&&this.setOr(e),e instanceof Q&&this.setDor(e)}getOutputBuffer(){return this.outputBuffer}statistics(){let e=0,t=[];for(const[t,s]of Object.entries(this.instructionCounter))e+=s;for(const[s,i]of Object.entries(this.instructionCounter))e&&t.push(`${s}: ${i/e*100}`);return t.join("\n")}run(){for(this.pc=0;this.pc<this.instructionArray.length;this.pc++)this.runInstruction(this.instructionArray[this.pc])}}class Y{constructor(){this.block=[],this.runner=null}toString_t(e){return e instanceof Y?this.toStringArray_t(e.block):[e.toString()]}getStdoutResponse(){return this.runner.getStdoutResponse()}getRawStdoutBuffer(){return this.runner.getRawStdoutBuffer()}toStringArray_t(e){let t=[];for(let s=0,i=e.length;s<i;s++){let i=this.toString_t(e[s]);for(let e=0,s=i.length;e<s;e++)t.push(i[e])}return t}toStringArray(){return this.toStringArray_t(this.block)}toString(){return this.toStringArray_t(this.block).join("\n")}push(e){this.block.push(e)}flatten_t(e,t){if(e instanceof Y)for(let s=0,i=e.block.length;s<i;s++)this.flatten_t(e.block[s],t);else t.push(e)}flatten(){let e=new Y;return this.flatten_t(this,e),e}getRegValue(e){return this.runner.getRegValue(e)}getOutputBuffer(){return this.runner.getOutputBuffer()}getPopback(e,t){let s=0;for(;e<t.length&&t[e]instanceof oe;)s+=parseInt(t[e].bytes),e++;return s}markPopBacks(e,t,s){for(;e<s.length&&s[e]instanceof oe;)t[e]=1,e++}removeUselessPushPopBlocks(e){let t=new Y,s=new Array(e.length).fill(0);for(let i=0,r=e.length;i<r;i++)s[i]||(e[i]instanceof oe?t.push(new oe(this.getPopback(i,e))):t.push(e[i])),this.markPopBacks(i,s,e);return t}removeComplementaryPushPopBlocks(e){let t=new Y,s=new Array(e.length).fill(0);for(let t=0,i=e.length-1;t<i;t++)e[t]instanceof re&&e[t+1]instanceof oe&&4==parseInt(e[t+1].bytes)?(s[t]=1,s[t+1]=1):e[t]instanceof re&&e[t+1]instanceof oe&&(s[t]=1,e[t+1].bytes=parseInt(e[t+1].bytes)-4);for(let i=0,r=e.length;i<r;i++)s[i]||t.push(e[i]);return t}optimize(){this.block=this.flatten().block;let e=this.removeUselessPushPopBlocks(this.block).block;this.block=this.removeComplementaryPushPopBlocks(e).block}run(){this.runner=new q(this.flatten().block),this.runner.run()}}class Z{toString(){return"UNDEFINED REGISTER"}}const X={MEM_TO_REG:1,REG_TO_REG:2,REG_TO_MEM:3,NUMBER_TO_REG:4,STACK_TO_REG:5,REG_TO_STACK:6,REG_MEM_TO_REG:7,REG_TO_MEM_REG:8};class Q extends Z{constructor(e){super(),this.reg=e}toString(){return`SETDOR $${this.reg}`}}class ee extends Z{constructor(e,t,s){super(),this.dst=e,this.src=t,this.type=s}toString(){switch(this.type){case X.NUMBER_TO_REG:return`MOV $${this.dst} ${this.src}`;case X.REG_TO_REG:return`MOV $${this.dst} $${this.src}`;case X.MEM_TO_REG:return`MOV $${this.dst} [${this.src}]`;case X.STACK_TO_REG:return 0==this.src?`MOV $${this.dst} [$st]`:`MOV $${this.dst} [$st-${this.src}]`;case X.REG_MEM_TO_REG:return`MOV $${this.dst} [$${this.src}]`;case X.REG_TO_MEM_REG:return`MOV [$${this.dst}] $${this.src}`;case X.REG_TO_STACK:return 0==this.dst?`MOV [$st] $${this.src}`:`MOV [$st-${this.dst}] $${this.src}`}}}class te extends Z{constructor(e,t,s){super(),this.dst=e,this.b=t,this.c=s}toString(){return`ADD $${this.dst} $${this.b} $${this.c}`}}class se extends Z{constructor(e,t,s){super(),this.dst=e,this.b=t,this.c=s}toString(){return`SUB $${this.dst} $${this.b} $${this.c}`}}class ie extends Z{constructor(e,t,s){super(),this.dst=e,this.b=t,this.c=s}toString(){return`MUL $${this.dst} $${this.b} $${this.c}`}}class re extends Z{constructor(e){super(),this.register=e}toString(){return`PUSH $${this.register}`}}const ne=1,he=2;class oe extends Z{constructor(e,t=ne){super(),this.bytes=e,this.type=t}toString(){switch(this.type){case ne:return`POP ${this.bytes}`;case he:return`POP $${this.bytes}`}return""}}class ae extends Z{constructor(e,t){super(),this.regA=e,this.regB=t}toString(){return`CMP $${this.regA} $${this.regB}`}}class le extends Z{constructor(e){super(),this.regA=e}toString(){return`SETNE $${this.regA}`}}class ce extends Z{constructor(e){super(),this.regA=e}toString(){return`SETE $${this.regA}`}}class ue extends Z{constructor(e,t){super(),this.regA=e,this.regB=t}toString(){return`TEST $${this.regA} $${this.regB}`}}class de extends Z{constructor(e){super(),this.regA=e}toString(){return`SETNZ $${this.regA}`}}class ge extends Z{constructor(e,t){super(),this.regA=e,this.regB=t}toString(){return`OR $${this.regA} $${this.regB}`}}class pe extends Z{constructor(e){super(),this.regA=e}toString(){return`SETGE $${this.regA}`}}class fe extends Z{constructor(e){super(),this.regA=e}toString(){return`SETLE $${this.regA}`}}class me extends Z{constructor(e){super(),this.label=e}toString(){return`JZ ${this.label}`}}class be extends Z{constructor(e){super(),this.label=e}toString(){return`:${this.label}`}}const ke={LABEL:1,REGISTER:2};class Re extends Z{constructor(e,t=ke.LABEL){super(),this.value=e,this.type=t}toString(){switch(this.type){case ke.LABEL:return`JMP ${this.value}`;case ke.REGISTER:return`JMP $${this.value}`}}}class Se extends Z{constructor(e,t){super(),this.a=e,this.b=t}toString(){return`DIV $${this.a} $${this.b}`}}class Ie extends Z{constructor(e,t){super(),this.reg=e,this.offset=t}toString(){return`PRP $${this.reg} ${this.offset}`}}const ve={MEMORY:1,REGISTER:2};class we extends Z{constructor(e,t=ve.REGISTER){super(),this.value=e,this.type=t}toString(){switch(this.type){case ve.REGISTER:return`PRR $${this.value} 4`;case ve.MEMORY:return`PRR [${this.value}] 4`}}}let Ae=0;class ye{constructor(e){this.chomp=e,this.left=null,this.right=null,this.nodeID="expr-node-"+Ae++,this.register=null}}const Te=1,Ce=2;class _e{constructor(e){this.expressionChomp=e,this.root=null,this.precedence=[["&&","||"],["==","!=","<=",">=","<",">"],["^","&","|","<<",">>"],["+","-"],["*","/","%"]],this.returnType=Te}toString_t(e){if(!e.left&&!e.right)return e.chomp.buffer;let t=this.toString_t(e.left),s=this.toString_t(e.right);return`(${t+e.chomp.buffer+s})`}toString(){return this.toString_t(this.root)}createNode(e,t,s){let i=new ye(s);return i.left=e,i.right=t,i}isNodeVariable(e){return e.chomp.type==l}isNodeMethodCall(e){return!(!e||!e.chomp)&&e.chomp.type==V}getExpressionRegister(e){return e.expressionTree.root.register}getRegister(e){return this.root.register}getNodeMethodCallRegisterResponse(e,t,s,i){const r=e.chomp.childrenChomps,n=r[0],h=r[1].childrenChomps,o=Date.now();s.freeze();for(let e=0,r=h.length;e<r;e++){const r=h[e];r.expressionTree.addInstructionToBlockWithOrder(t,i,s);const n=this.getExpressionRegister(r);t.push(new re(n)),i.freeRegister(n),s.push(`${o}_${e}`,4)}return s.push(`return_address_offset_${o}`,4),t.push(new Ie("ret",3)),t.push(new re("ret")),t.push(new Re(`_${n.buffer}`)),t.push(new oe(s.getFreezeTopDiff())),s.pop(),t.push(new re("rsp")),s.push(e.nodeID,4),"rsp"}getNodeValue(e,t,s,i){if(this.isNodeMethodCall(e))return this.getNodeMethodCallRegisterResponse(e,t,s,i);return this.isNodeVariable(e)?s.getStackOffset(e.chomp.buffer):e.chomp.buffer}getNodeMovType(e){if(this.isNodeMethodCall(e))return X.REG_TO_REG;return this.isNodeVariable(e)?X.STACK_TO_REG:X.NUMBER_TO_REG}findRegisterForNode(e,t){const s=t.isNodeIDUsed(e.nodeID);if(null!=s)return s;const i=t.findUnusedRegister();return t.saveRegisterID(i,e.nodeID),e.register=i,i}isLeaf(e){return!e.left&&!e.right}pushNonPointerNode(e,t,s,i){let r=this.findRegisterForNode(e,s);return t.push(new ee(r,this.getNodeValue(e,t,i,s),this.getNodeMovType(e))),r}pushPointerNode(e,t,s,i){const r=e.chomp.childrenChomps[0];r.expressionTree.addInstructionToBlockWithOrder(t,s,i);let n=this.findRegisterForNode(e,s);const h=r.expressionTree.getRegister(s);return t.push(new ee(n,h,X.REG_MEM_TO_REG)),n!=h&&s.freeRegister(h),n}pushLeafNode(e,t,s,i){return e.chomp.type===G?this.pushPointerNode(e,t,s,i):this.pushNonPointerNode(e,t,s,i)}pushMov(e,t,s,i){if(this.isLeaf(e))return this.pushLeafNode(e,t,s,i);let r=this.findRegisterForNode(e,s);return t.push(new ee(r,i.getStackOffset(e.nodeID),X.STACK_TO_REG)),r}movAndGetFreeRegisters(e,t,s,i){let r=[null,null],n=[e.left,e.right];for(let e=0;e<n.length;e++){const h=n[e];this.isNodeMethodCall(h)&&(this.getNodeMethodCallRegisterResponse(h,t,i,s),r[e]=this.findRegisterForNode(h,s))}for(let e=0,h=r.length;e<h;e++)null==r[e]?r[e]=this.pushMov(n[e],t,s,i):t.push(new ee(r[e],i.getStackOffset(n[e].nodeID),X.STACK_TO_REG));return r}freeRegisters(e,t){for(let s=0,i=e.length;s<i;s++)t.freeRegister(e[s])}addNodeToTheStack(e,t,s,i,r){s.push(new re(t)),i.push(e.nodeID,4),this.freeRegisters([t],r)}add_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),h=this.findRegisterForNode(e,s);t.push(new te(h,r,n)),this.addNodeToTheStack(e,h,t,i,s),this.freeRegisters([r,n],s)}sub_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),h=this.findRegisterForNode(e,s);t.push(new se(h,r,n)),this.addNodeToTheStack(e,h,t,i,s),this.freeRegisters([r,n],s)}mul_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),h=this.findRegisterForNode(e,s);t.push(new ie(h,r,n)),this.addNodeToTheStack(e,h,t,i,s),this.freeRegisters([r,n],s)}div_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new Se(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new ee(h,"LO",X.REG_TO_REG)),this.addNodeToTheStack(e,h,t,i,s)}reminder_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new Se(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new ee(h,"HI",X.REG_TO_REG)),this.addNodeToTheStack(e,h,t,i,s)}equal_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new ae(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new ce(h)),this.addNodeToTheStack(e,h,t,i,s)}setGe_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new ae(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new pe(h)),this.addNodeToTheStack(e,h,t,i,s)}setLe_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new ae(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new fe(h)),this.addNodeToTheStack(e,h,t,i,s)}notEqual_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new ae(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new le(h)),this.addNodeToTheStack(e,h,t,i,s)}less_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new ae(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new ee(h,"CF",X.REG_TO_REG)),this.addNodeToTheStack(e,h,t,i,s)}more_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new ae(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new ee(h,"CT",X.REG_TO_REG)),this.addNodeToTheStack(e,h,t,i,s)}doubleAnd_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new ae(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new de(h)),this.addNodeToTheStack(e,h,t,i,s)}doubleOr_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),h=this.findRegisterForNode(e,s);t.push(new ge(r,n)),t.push(new Q(h)),this.addNodeToTheStack(e,h,t,i,s),this.freeRegisters([r,n],s)}addInstructions(e,t,s,i){switch(e.chomp.buffer){case"+":this.add_InstructionSet(e,t,s,i);break;case"-":this.sub_InstructionSet(e,t,s,i);break;case"*":this.mul_InstructionSet(e,t,s,i);break;case"==":this.equal_InstructionSet(e,t,s,i);break;case"<":this.less_InstructionSet(e,t,s,i);break;case">":this.more_InstructionSet(e,t,s,i);break;case"!=":this.notEqual_InstructionSet(e,t,s,i);break;case"&&":this.doubleAnd_InstructionSet(e,t,s,i);break;case"||":this.doubleOr_InstructionSet(e,t,s,i);break;case">=":this.setGe_InstructionSet(e,t,s,i);break;case"<=":this.setLe_InstructionSet(e,t,s,i);break;case"/":this.div_InstructionSet(e,t,s,i);break;case"%":this.reminder_InstructionSet(e,t,s,i)}}addInstructionToBlock_t(e,t,s,i){(e.left||e.right)&&(this.addInstructionToBlock_t(e.left,t,s,i),this.addInstructionToBlock_t(e.right,t,s,i),this.addInstructions(e,t,s,i))}addInstructionToBlock(e,t,s){if(this.root.left||this.root.right)this.addInstructionToBlock_t(this.root,e,t,s);else{let i=this.findRegisterForNode(this.root,t);e.push(new ee(i,this.getNodeValue(this.root,e,s,t),this.getNodeMovType(this.root)))}}expressionRoot(e){let t=new _e(e);return t.build(),t.root}isOperationLeaf(e){return!this.isLeaf(e)&&(this.isLeaf(e.left)&&this.isLeaf(e.right))}numberOfOperations(e){return e?this.numberOfOperations(e.left)+this.numberOfOperations(e.right)+1:0}isVisited(e,t){return e.nodeID in t}order_t(e,t,s){if(!this.isVisited(e,t)&&!this.isLeaf(e)){if(this.isOperationLeaf(e))return s.push(e.left),s.push(e.right),s.push(e),t[e.left.nodeID]=1,t[e.right.nodeID]=1,void(t[e.nodeID]=1);if(this.isVisited(e.left,t)&&this.isVisited(e.right,t))return t[e.nodeID]=1,void s.push(e);if(this.isVisited(e.left,t)&&this.isLeaf(e.right))return t[e.nodeID]=1,t[e.right.nodeID]=1,s.push(e.right),void s.push(e);if(this.isVisited(e.right,t)&&this.isLeaf(e.left))return t[e.nodeID]=1,t[e.left.nodeID]=1,s.push(e.left),void s.push(e);this.order_t(e.left,t,s),this.order_t(e.right,t,s)}}order(){let e={},t=[],s=this.numberOfOperations(this.root);const i=this.root;if(this.isLeaf(i))return[i];for(;t.length<s;)this.order_t(i,e,t);return t}addResultToStack(e,t,s){if(this.returnType==Ce){const i=this.getRegister(t);e.push(new re(i)),s.push(this.root.nodeID,4),this.freeRegisters([i],t)}}pushLastNode(e,t,s){this.pushMov(this.root,e,t,s);let i=this.findRegisterForNode(this.root,t);e.push(new re(i)),s.push(this.root.nodeID,4),e.push(new oe(s.getFreezeTopDiff())),s.pop(),this.addResultToStack(e,t,s),this.freeRegisters([i],t)}addInstructionToBlockWithOrder(e,t,s,i=Te){if(s.freeze(),this.returnType=i,!this.root.left&&!this.root.right)return void this.pushLastNode(e,t,s);const r=this.order();for(let i=0,n=r.length;i<n;i++)this.addInstructions(r[i],e,t,s);e.push(new oe(s.getFreezeTopDiff())),s.pop(),this.addResultToStack(e,t,s)}build_t(e=0,t){let s=this.expressionChomp.childrenChomps;if(e>=this.precedence.length)return s[t[0]].type==z?this.expressionRoot(s[t[0]]):new ye(s[t[0]]);let i=this.build_t(e+1,t);for(;t[0]+1<s.length;){const r=s[t[0]+1];let n=!1;for(let s=0,h=this.precedence[e].length;s<h;s++)if(this.precedence[e][s]==r.buffer){t[0]+=2;const s=this.build_t(e+1,t);i=this.createNode(i,s,r),n=!0}if(!n)break}return i}build(){this.root=this.build_t(0,[0])}}class $e{constructor(){this.registerToID={},this.maxRegisters=32,this.IDToRegisters={}}findUnusedRegister(){for(let e=0;e<this.maxRegisters;e++)if(!(e in this.registerToID))return e;return null}getUsedRegisters(){let e=[];for(const[t,s]of Object.entries(this.registerToID))e.push(t);return e}registerFromID(e){return this.IDToRegisters[e]}isNodeIDUsed(e){return e in this.IDToRegisters?this.IDToRegisters[e]:null}saveRegisterID(e,t){this.registerToID[e]=t,this.IDToRegisters[t]=e}getRegisterFromID(e){return this.registerWithNodeID[e]}freeRegister(e){this.registerToID[e]in this.IDToRegisters&&delete this.IDToRegisters[this.registerToID[e]],e in this.registerToID&&delete this.registerToID[e]}}class xe{constructor(){this.stackValues=[],this.offset={},this.stackOffset=[],this.freezeHistory=[0],this.variableNames=[],this.freezeChunks=[0],this.methodFreezeChunk=0}getStackLastIndex(){return this.stackOffset.length?this.stackOffset[this.stackOffset.length-1]:0}push(e,t){this.offset[e]={stack_offset:this.getStackLastIndex(),size:t},this.stackOffset.push(this.getStackLastIndex()+t),this.variableNames.push(e)}freezeMethodPointer(){this.methodFreezeChunk=this.getStackLastIndex()}freeze(){this.freezeChunks.push(this.stackOffset.length),this.freezeHistory.push(this.getStackLastIndex())}topVariableName(){return this.variableNames.length?this.variableNames[this.variableNames.length-1]:null}pop(){if(this.freezeHistory.length){for(let e=this.stackOffset.length-1;e>=this.freezeChunks[this.freezeChunks.length-1];e--){this.stackOffset.pop();const e=this.topVariableName();delete this.offset[e],this.variableNames.pop()}this.freezeHistory.pop(),this.freezeChunks.pop()}}getFreezeTopDiff(){return this.freezeHistory.length?this.getStackLastIndex()-this.freezeHistory[this.freezeHistory.length-1]:this.getStackLastIndex()}getFreezeTopDiffFromMethod(){return this.getStackLastIndex()-this.methodFreezeChunk}getStackOffset(e){return e in this.offset?this.getStackLastIndex()-this.offset[e].stack_offset:null}}class Ee{constructor(e){this.ast=e,this.registerMem=new $e,this.registerStack=new xe,this.globalStack=new xe,this.labelID=0,this.assignationID=0}buildExpressionTrees(e){let t=A.searchChompByType(e,{type:z});for(let e=0,s=t.length;e<s;e++){let s=new _e(t[e]);t[e].expressionTree||(s.build(),t[e].expressionTree=s)}}createExpressionAsm(e,t,s=Te){e.expressionTree.addInstructionToBlockWithOrder(t,this.registerMem,this.registerStack,s)}saveExpressionResult(e,t){const s=e.expressionTree.root.register;t.push(new re(s)),this.registerMem.freeRegister(s)}loadVariableInStack(e,t,s){this.createExpressionAsm(e,s);const i=this.getExpressionRegister(e),r=this.registerStack.getStackOffset(t.buffer);s.push(new ee(r,i,X.REG_TO_STACK)),this.registerMem.freeRegister(i)}getExpressionStackPoint(e){return this.registerStack.getStackOffset(e.expressionTree.root.nodeID)}loadPointerInStack(e,t,s){this.registerStack.freeze(),this.createExpressionAsm(e,s,Ce),this.createExpressionAsm(t,s,Ce);let i=this.registerMem.findUnusedRegister();this.registerMem.saveRegisterID(i,"assignation-id-"+this.assignationID++);let r=this.registerMem.findUnusedRegister();this.registerMem.saveRegisterID(r,"assignation-id-"+this.assignationID++),s.push(new ee(r,this.getExpressionStackPoint(t),X.STACK_TO_REG)),s.push(new ee(i,this.getExpressionStackPoint(e),X.STACK_TO_REG)),s.push(new ee(r,i,X.REG_TO_MEM_REG)),s.push(new oe(this.registerStack.getFreezeTopDiff())),this.registerMem.freeRegister(i),this.registerMem.freeRegister(r),this.registerStack.pop()}loadExpressionOnStack(e,t,s){if(t.type===G)this.loadPointerInStack(e,t.childrenChomps[0],s);else this.loadVariableInStack(e,t,s)}compileInitialization(e,t=this.registerStack){const s=e.childrenChomps;let i=new Y;for(let e=1,t=s.length;e<t;e++){const t=s[e],r=t.childrenChomps[0],n=t.childrenChomps[1];this.createExpressionAsm(n,i),this.registerStack.push(r.buffer,4),this.saveExpressionResult(n,i)}return i}compileAssignation(e){const t=e.childrenChomps;let s=new Y;const i=t[1],r=t[0];return this.loadExpressionOnStack(i,r,s),s}popStackValues(e){const t=this.registerStack.getFreezeTopDiff();t&&e.push(new oe(t))}getExpressionRegister(e){return e.expressionTree.root.register}nextLabel(){return this.labelID++}compileWhile(e){let t=new Y;const s=e.childrenChomps;let i=s[0],r=s[1];const n=`_label${this.nextLabel()}`;t.push(new be(n)),this.createExpressionAsm(i,t);const h=this.getExpressionRegister(i),o=`_label${this.nextLabel()}`;return t.push(new ue(h,h)),this.registerMem.freeRegister(h),t.push(new me(o)),t.push(this.compileBlock(r)),t.push(new Re(n)),t.push(new be(o)),t}compileFor(e){let t=new Y;const s=e.childrenChomps;let i=s[0],r=s[1],n=s[2],h=s[3];switch(this.registerStack.freeze(),t.push(new be(`_startForLoop${this.nextLabel()}`)),i.type){case C:t.push(this.compileInitialization(i));break;case w:t.push(this.compileAssignation(i))}const o=`_label${this.nextLabel()}`;t.push(new be(o)),this.createExpressionAsm(r,t);const a=this.getExpressionRegister(r),l=`_label${this.nextLabel()}`;return t.push(new ue(a,a)),this.registerMem.freeRegister(a),t.push(new me(l)),t.push(this.compileBlock(h)),t.push(this.compileAssignation(n)),t.push(new Re(o)),t.push(new be(l)),t.push(new oe(this.registerStack.getFreezeTopDiff())),this.registerStack.pop(),t}compileLoop(e){switch(e.buffer){case"while":return this.compileWhile(e);case"for":return this.compileFor(e)}return new Y}popReturnStackPointer(e){const t=this.registerStack.getFreezeTopDiffFromMethod();t&&e.push(new oe(t))}compileReturnMethod(e){const t=e.childrenChomps[0];let s=new Y;this.createExpressionAsm(t,s);const i=this.getExpressionRegister(t);return s.push(new ee("ret",this.registerStack.getStackOffset("return_address"),X.STACK_TO_REG)),s.push(new ee("rsp",i,X.REG_TO_REG)),this.popReturnStackPointer(s),s.push(new Re("ret",ke.REGISTER)),this.registerMem.freeRegister(i),s}compileConditionalBlock(e){let t=new Y;const s=e.childrenChomps,i=s[0],r=s[1];this.createExpressionAsm(i,t);const n=this.getExpressionRegister(i),h=`_label${this.nextLabel()}`;return t.push(new ue(n,n)),this.registerMem.freeRegister(n),t.push(new me(h)),t.push(this.compileBlock(r)),t.push(new be(h)),t}compileExpression(e){let t=new Y;return this.createExpressionAsm(e,t),t}compileBlock(e,t=!0){let s=new Y;this.buildExpressionTrees(e);const i=e.childrenChomps;this.registerStack.freeze();for(let e=0,t=i.length;e<t;e++){const t=i[e];switch(t.type){case w:s.push(this.compileAssignation(t));break;case C:s.push(this.compileInitialization(t));break;case N:s.push(this.compileBlock(t));break;case $:s.push(this.compileLoop(t));break;case M:s.push(this.compileReturnMethod(t));break;case E:s.push(this.compileConditionalBlock(t));break;case z:s.push(this.compileExpression(t))}}return t&&this.popStackValues(s),this.registerStack.pop(),s}isMethodMain(e){return"main"==e.buffer}compileMainMethod(e,t){let s=new Y;const i=`_${e}`;return s.push(new be(i)),s.push(this.compileBlock(t)),s}compileMethods(e){const t=e.childrenChomps;let s=new Y;const i=t[0],r=t[1].childrenChomps,n=t[2],h=i.childrenChomps[1];if(this.isMethodMain(h))return this.compileMainMethod(h.buffer,n);const o=`_${h}`;s.push(new be(o)),this.registerStack.freeze();for(let e=0;e<r.length;e++){const t=r[e].childrenChomps[1];this.registerStack.push(t.buffer,4)}return this.registerStack.push("return_address",4),this.registerStack.freezeMethodPointer(),s.push(this.compileBlock(n,!1)),this.registerStack.pop(),s}compileProgram(e,t=!0){let s=e.childrenChomps;this.buildExpressionTrees(e);let i=new Y;i.push(new Re("_main"));for(let e=0,t=s.length;e<t;e++){const t=s[e];if(t.type===O)i.push(this.compileMethods(t))}return t&&i.optimize(),i}compile(){}}const Ne=1,De=2;class Ve{constructor(e,t={zeroReg:31,stackPointerRegister:30,stddoutRegister:29,freeRegister:28,hi:27,lo:26,testRegister:25,rsp:24,ret:23,bitSplitterRegister:22},s=1048576){this.block=e,this.stackPointerRegister=t.stackPointerRegister,this.stddoutRegister=t.stddoutRegister,this.memorySize=s,this.hi=t.hi,this.lo=t.lo,this.registerData=t,this.memory=new Array(this.memorySize).fill(0),this.register=new Array(40).fill(0),this.pc=0}getRawStdoutBuffer(){let e=this.registerValue(this.stddoutRegister);const t=this.getNumberAtAddress(this.memory,e-4);let s="";for(let i=0;i<t;i++)s+=String.fromCharCode(this.memory[i+e]);return s}getStackPointer(){return this.registerValue(this.stddoutRegister)}registerValue(e){return this.register[parseInt(e)]}printPointerBytes(e,t){let s=[];for(let i=0;i<e;i++)s.push(this.memory[t+i]);return s}printStack(e){let t=[],s=this.registerValue(this.stackPointerRegister);for(let i=0;i<e;i++)t.push(this.memory[s+i]);return t.join(" ")}unsigned(e){return e>=0?e:2**32- -(e+1)}positiveNumberToByteArray(e){const t=[0,0,0,0];return t[0]=255&e,t[1]=e>>8&255,t[2]=e>>16&255,t[3]=e>>24&255,t}negativeNumberToByteArray(e){const t=2**32+e;return this.positiveNumberToByteArray(t)}numberToByteArray(e){return e>=0?this.positiveNumberToByteArray(e):this.negativeNumberToByteArray(e)}saveRegInMemory(e,t,s){let i=this.numberToByteArray(this.registerValue(t));for(let t=0,r=i.length;t<r;t++)this.memory[e+t+s]=i[t]}get32ByteInteger(e){return e<2**31?e:-(2**32-e)}getNumberAtAddress(e,t,s=Ne){switch(s){case Ne:{let s=0,i=1;for(let r=0;r<4;r++)s+=e[t+r]*i,i*=256;return this.get32ByteInteger(s)}case De:return e[t]}return 0}saveNumberInReg(e,t,s){let i=this.getNumberAtAddress(this.memory,e+s);this.register[parseInt(t)]=i}runInstruction(e){e instanceof Oe&&(this.register[parseInt(e.dst)]=this.registerValue(e.srcA)+this.registerValue(e.srcB)),e instanceof Le&&(this.register[parseInt(e.d)]=this.registerValue(e.s)-this.registerValue(e.t)),e instanceof We&&(this.register[parseInt(e.d)]=this.registerValue(e.s)|this.registerValue(e.t)),e instanceof Je&&(this.register[parseInt(e.d)]=this.registerValue(e.s)&this.registerValue(e.t)),e instanceof ze&&(this.register[this.lo]=Math.floor(this.registerValue(e.s)/this.registerValue(e.t)),this.register[this.hi]=this.registerValue(e.s)%this.registerValue(e.t)),e instanceof tt&&(this.pc=parseInt(e.register)),e instanceof Xe&&this.registerValue(e.s)==this.registerValue(e.t)&&(this.pc+=parseInt(e.label)),e instanceof Pe&&(this.register[parseInt(e.t)]=this.registerValue(e.s)+parseInt(e.immediate)),e instanceof Ye&&(this.pc=this.registerValue(e.register)),e instanceof Ge&&(this.register[this.lo]=this.registerValue(e.s)*this.registerValue(e.t)),e instanceof Ze&&(this.register[parseInt(e.d)]=this.booleanToNumber(this.registerValue(e.s)<this.registerValue(e.t))),e instanceof it&&(this.register[parseInt(e.d)]=this.booleanToNumber(this.unsigned(this.registerValue(e.s))<this.unsigned(this.registerValue(e.t)))),e instanceof He&&(this.register[parseInt(e.d)]=this.registerValue(e.s)^this.registerValue(e.t)),e instanceof je&&(this.register[parseInt(e.d)]=this.registerValue(e.s)^parseInt(e.i)),e instanceof Ue&&this.saveRegInMemory(this.registerValue(e.s),e.t,parseInt(e.i)),e instanceof Ke&&this.saveNumberInReg(this.registerValue(e.s),e.t,parseInt(e.i)),e instanceof qe&&(this.register[parseInt(e.d)]=this.registerValue(e.s)&parseInt(e.i)),e instanceof Fe&&(this.register[parseInt(e.s)]=this.registerValue(e.t)<<parseInt(e.i))}booleanToNumber(e){return e?1:0}run(){for(this.pc=0;this.pc<this.block.length;this.pc++)this.runInstruction(this.block[this.pc])}}class Be{constructor(e,t,s,i=!0,r={zeroReg:31,stackPointerRegister:30,stddoutRegister:29,freeRegister:28,hi:27,lo:26,testRegister:25,rsp:24,ret:23,bitSplitterRegister:22},n=1048576){this.registerBlock=e.flatten(),this.registerBlock.optimize(),this.stddout=t,this.stackPointer=s,this.block=[],this.memorySize=n,this.registerData=r,this.registerCount=32,this.usedRegisters={HI:this.registerData.hi,LO:this.registerData.lo,rsp:this.registerData.rsp,ret:this.registerData.ret},this.labelsOffsets={},i&&(this.prepareHeader(),this.iterateBlock(),this.iterateImediates(),this.createLabelOffsets())}iterateImediates(){let e=[];for(let t=0,s=this.block.length;t<s;t++)this.block[t]instanceof Pe?this.addNumberToBlock(this.block[t],e):e.push(this.block[t]);this.block=e}getStdoutResponse(){let e=[];for(let t=0,s=this.runner.getNumberAtAddress(this.runner.memory,this.stddout-4);t<s;t+=4)e.push(this.getNumberAtAddress(this.runner.memory,this.stddout+t));return e.join("\n")}addLabelFromImmediate(e,t){if(this.doesNumberFitInImmediate(e.register))return void t.push(e);let s=parseInt(e.register),i=65535&s,r=s>>16;t.push(new Pe(this.registerData.bitSplitterRegister,this.registerData.zeroReg,i)),t.push(new Pe(this.registerData.freeRegister,this.registerData.zeroReg,r)),t.push(new Fe(this.registerData.freeRegister,this.registerData.freeRegister,16)),t.push(new We(this.registerData.freeRegister,this.registerData.freeRegister,this.registerData.bitSplitterRegister)),t.push(new Ye(this.registerData.freeRegister))}rebuildJumpInstructions(){let e=[];for(let t=0,s=this.block.length;t<s;t++)this.block[t]instanceof tt?this.addLabelFromImmediate(this.block[t],e):e.push(this.block[t]);this.block=e}createLabelOffsets(){for(let e=0,t=this.block.length;e<t;e++)this.block[e]instanceof et&&(this.labelsOffsets[this.block[e].label]=e,this.block[e]=new Qe);for(let e=0,t=this.block.length;e<t;e++)this.block[e]instanceof tt&&(this.block[e]=new tt(this.labelsOffsets[this.block[e].register])),this.block[e]instanceof Xe&&(this.block[e].label=this.labelsOffsets[this.block[e].label]-e),this.block[e]instanceof st&&(this.block[e]=new Pe(this.getRegisterValue(this.block[e].reg),this.registerData.zeroReg,e+this.block[e].offset))}numberToUnsignedRpresentation(e){return e>=0?e:2**32-e+1}doesNumberFitInImmediate(e){return parseInt(e)<=65536}iterateBlock(){const e=this.registerBlock.block;for(let t=0,s=e.length;t<s;t++){const s=e[t];s instanceof ee&&this.addMoveBlock(s,e,t),s instanceof re&&this.addPushBlock(s),s instanceof te&&this.addAddInstruction(s),s instanceof oe&&this.addPopInstruction(s),s instanceof ie&&this.addMultInstruction(s),s instanceof Se&&this.addDivInstruction(s),s instanceof Re&&this.addJumpInstruction(s),s instanceof be&&this.block.push(new et(s.label)),s instanceof ae||(s instanceof le&&this.addSetneInstruction(s,e,t),s instanceof ce&&this.addSeteInstruction(s,e,t),s instanceof pe&&this.addSetgeInstruction(s,e,t),s instanceof fe&&this.addSetleInstruction(s,e,t),s instanceof de&&this.addSetnzInstruction(s,e,t),s instanceof Q&&this.addSetdorInstruction(s,e,t),s instanceof se&&this.addSubInstruction(s),s instanceof ue&&this.addSetTestInstruction(s,e,t),s instanceof me&&this.addJzInstruction(s),s instanceof Ie&&this.addPrpInstruction(s))}}addPrpInstruction(e){this.block.push(new st(e.reg,e.offset))}addJzInstruction(e){this.block.push(new Xe(this.registerData.testRegister,this.registerData.zeroReg,e.label))}addSetTestOnEqual(e){this.block.push(new it(this.registerData.testRegister,this.registerData.zeroReg,e.regA))}addSetTestInstruction(e){e.regA!=e.regB?(this.block.push(new Ze(e.regA,this.registerData.zeroReg,e.regA)),this.block.push(new Ze(e.regB,this.registerData.zeroReg,e.regB)),this.block.push(new Je(this.registerData.testRegister,e.regA,e.regB))):this.addSetTestOnEqual(e)}addSubInstruction(e){this.block.push(new Le(e.dst,e.b,e.c))}addSetdorInstruction(e,t,s){let i=this.searchClosestOr(t,s);this.block.push(new it(i.regA,this.registerData.zeroReg,i.regA)),this.block.push(new it(i.regB,this.registerData.zeroReg,i.regB)),this.block.push(new We(e.reg,i.regA,i.regB))}addSetnzInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new it(i.regA,this.registerData.zeroReg,i.regA)),this.block.push(new it(i.regB,this.registerData.zeroReg,i.regB)),this.block.push(new Je(e.regA,i.regA,i.regB))}addSetleInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new Ze(e.regA,i.regB,i.regA)),this.block.push(new je(e.regA,e.regA,1))}addSetgeInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new Ze(e.regA,i.regA,i.regB)),this.block.push(new je(e.regA,e.regA,1))}addSeteInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new He(i.regA,i.regA,i.regB)),this.block.push(new it(e.regA,this.registerData.zeroReg,i.regA)),this.block.push(new je(e.regA,e.regA,1))}addSetneInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new He(i.regA,i.regA,i.regB)),this.block.push(new it(e.regA,this.registerData.zeroReg,i.regA))}addJumpInstruction(e){switch(e.type){case ke.REGISTER:this.block.push(new Ye(this.getRegisterValue(e.value)));break;case ke.LABEL:this.block.push(new tt(e.value))}}getRegisterValue(e){return e in this.usedRegisters?this.usedRegisters[e]:e}addDivInstruction(e){this.block.push(new ze(e.a,e.b))}addMultInstruction(e){this.block.push(new Ge(e.b,e.c)),this.block.push(new Pe(e.dst,this.registerData.lo,0))}addPushBlock(e){this.block.push(new Ue(this.getRegisterValue(e.register),0,this.registerData.stackPointerRegister)),this.block.push(new Pe(this.registerData.stackPointerRegister,this.registerData.stackPointerRegister,4))}addAddInstruction(e){this.block.push(new Oe(e.dst,e.b,e.c))}addPopInstruction(e){this.block.push(new Pe(this.registerData.freeRegister,this.registerData.zeroReg,e.bytes)),this.block.push(new Le(this.registerData.stackPointerRegister,this.registerData.stackPointerRegister,this.registerData.freeRegister))}searchClosestCmp(e,t){for(let s=t;s>=0;s--)if(e[s]instanceof ae)return e[s];return null}searchClosestOr(e,t){for(let s=t;s>=0;s--)if(e[s]instanceof ge)return e[s];return null}addSpecialMov(e,t,s){let i=this.searchClosestCmp(t,s);"CF"!=e.src?"CT"!=e.src?this.block.push(new Oe(this.getRegisterValue(e.dst),this.getRegisterValue(e.src),this.registerData.zeroReg)):this.block.push(new Ze(e.dst,i.regB,i.regA)):this.block.push(new Ze(e.dst,i.regA,i.regB))}addNumberToBlock(e,t){let s=e.t;if(this.doesNumberFitInImmediate(e.immediate))return void t.push(e);let i=parseInt(e.immediate),r=65535&i,n=i>>16;t.push(new Pe(this.registerData.bitSplitterRegister,this.registerData.zeroReg,r)),t.push(new Pe(s,this.registerData.zeroReg,n)),t.push(new Fe(s,s,16)),t.push(new We(s,s,this.registerData.bitSplitterRegister))}getPositiveLwInstructions(e,t,s){return t>=0?new Ke(e,t,s):(this.block.push(new Pe(this.registerData.freeRegister,this.registerData.zeroReg,-t)),this.block.push(new Le(this.registerData.freeRegister,s,this.registerData.freeRegister)),new Ke(e,0,this.registerData.freeRegister))}getPositiveSwInstructions(e,t,s){return t>=0?new Ue(e,t,s):(this.block.push(new Pe(this.registerData.freeRegister,this.registerData.zeroReg,-t)),this.block.push(new Le(this.registerData.freeRegister,s,this.registerData.freeRegister)),new Ue(e,0,this.registerData.freeRegister))}addMoveBlock(e,t,s){switch(e.type){case X.REG_TO_REG:this.addSpecialMov(e,t,s);break;case X.NUMBER_TO_REG:this.block.push(new Pe(this.getRegisterValue(e.dst),this.registerData.zeroReg,e.src));break;case X.STACK_TO_REG:this.block.push(this.getPositiveLwInstructions(this.getRegisterValue(e.dst),-e.src,this.registerData.stackPointerRegister));break;case X.REG_TO_STACK:this.block.push(this.getPositiveSwInstructions(this.getRegisterValue(e.src),-e.dst,this.registerData.stackPointerRegister));break;case X.REG_MEM_TO_REG:this.block.push(this.getPositiveLwInstructions(this.getRegisterValue(e.dst),0,this.getRegisterValue(e.src)));break;case X.REG_TO_MEM_REG:this.block.push(this.getPositiveSwInstructions(this.getRegisterValue(e.src),0,this.getRegisterValue(e.dst)))}}prepareHeader(){this.block.push(new We(this.registerData.zeroReg,this.registerData.zeroReg,this.registerData.zeroReg)),this.block.push(new Pe(this.registerData.stackPointerRegister,this.registerData.zeroReg,this.stackPointer)),this.block.push(new Pe(this.registerData.stddoutRegister,this.registerData.zeroReg,this.stddout))}run(){this.runner=new Ve(this.block,this.registerData,this.memorySize),this.runner.run()}toString_t(e=!1){let t=[];for(let s=0,i=this.block.length;s<i;s++)e?t.push(`${s}: ${this.block[s].toString()}`):t.push(this.block[s].toString());return t.join("\n")}toString(e=!1){return this.flatten().toString_t(e)}flatten_t(e,t){if(e instanceof Be)for(let s=0,i=e.block.length;s<i;s++)this.flatten_t(e.block[s],t);else t.push(e)}flatten(){let e=new Be(this.registerBlock,this.stddout,this.stackPointer,!1);return this.flatten_t(this,e),e}push(e){this.block.push(e)}}class Me{toString(){return"UNDEFINED REGISTER"}}class Oe extends Me{constructor(e,t,s){super(),this.dst=e,this.srcA=t,this.srcB=s}toString(){return`ADD $${this.dst} $${this.srcA} $${this.srcB}`}}class Pe extends Me{constructor(e,t,s){super(),this.t=e,this.s=t,this.immediate=s}toString(){return`ADDI $${this.t} $${this.s} ${this.immediate}`}}class ze extends Me{constructor(e,t){super(),this.s=e,this.t=t}toString(){return`DIV $${this.s} $${this.t}`}}class Ge extends Me{constructor(e,t){super(),this.s=e,this.t=t}toString(){return`MULT $${this.s} $${this.t}`}}class Fe extends Me{constructor(e,t,s){super(),this.s=e,this.t=t,this.i=s}toString(){return`SLL $${this.s} $${this.t} ${this.i}`}}class Le extends Me{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`SUB $${this.d} $${this.s} $${this.t}`}}class Ue extends Me{constructor(e,t,s){super(),this.t=e,this.i=t,this.s=s}toString(){return`SW $${this.t} ${this.i}($${this.s})`}}class Ke extends Me{constructor(e,t,s){super(),this.t=e,this.i=t,this.s=s}toString(){return`LW $${this.t} ${this.i}($${this.s})`}}class We extends Me{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`OR $${this.d} $${this.s} $${this.t}`}}class He extends Me{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`XOR $${this.d} $${this.s} $${this.t}`}}class je extends Me{constructor(e,t,s){super(),this.d=e,this.s=t,this.i=s}toString(){return`XORI $${this.d} $${this.s} ${this.i}`}}class Je extends Me{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`AND $${this.d} $${this.s} $${this.t}`}}class qe extends Me{constructor(e,t,s){super(),this.d=e,this.s=t,this.i=s}toString(){return`ANDI $${this.d} $${this.s} ${this.i}`}}class Ye extends Me{constructor(e){super(),this.register=e}toString(){return`JR $${this.register}`}}class Ze extends Me{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`SLT $${this.d} $${this.s} $${this.t}`}}class Xe extends Me{constructor(e,t,s){super(),this.s=e,this.t=t,this.label=s}toString(){return`BEQ $${this.s} $${this.t} ${this.label}`}}class Qe extends Me{constructor(){super()}toString(){return"NOOP"}}class et extends Me{constructor(e){super(),this.label=e}toString(){return`:${this.label}`}}class tt extends Me{constructor(e){super(),this.register=e}toString(){return`J ${this.register}`}}class st extends Me{constructor(e,t){super(),this.reg=e,this.offset=t}toString(){return`PRP $${this.reg} ${this.offset}`}}class it extends Me{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`SLTU $${this.d} $${this.s} $${this.t}`}}class rt{constructor(e,t=256,s=524288,i=1048576,r={zeroReg:31,stackPointerRegister:30,stddoutRegister:29,freeRegister:28,hi:27,lo:26,testRegister:25,rsp:24,ret:23,bitSplitterRegister:22}){this.code=e,this.stdout=t,this.stackPointer=s,this.memorySize=i,this.registerData=r,this.mips32Instructions=null,this.intermediaryASMInsturctions=null}compile(){let e=new W(this.code,[],!0,this.stdout).chomp();if(e.isInvalid())return!1;let t=new Ee(null);return this.intermediaryASMInsturctions=t.compileProgram(e),this.mips32Instructions=new Be(this.intermediaryASMInsturctions,this.stdout,this.stackPointer,!0,this.registerData,this.memorySize),!0}mips32Code(){return this.mips32Instructions}stdoutBuffer(){return this.mips32Instructions.runner.getRawStdoutBuffer()}run(){return!!this.mips32Instructions&&(this.mips32Instructions.run(),!0)}}module.exports=t})();