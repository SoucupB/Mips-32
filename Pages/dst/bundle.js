(()=>{var e={547:e=>{(()=>{"use strict";var t={d:(e,s)=>{for(var i in s)t.o(s,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:s[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},s={};t.r(s),t.d(s,{Mips32Compiler:()=>We});class i{static isNumeric(e){return e>="0"&&e<="9"}static isAlpha(e){return/^[a-zA-Z]$/.test(e)}static isOperator(e){return["+","-","*","/","%","<",">","|","^","&"].includes(e)}static isSeparator(e){return" "==e}static isCommaSeparator(e){return","==e}static isAssignationEnding(e){return";"==e}static pruneSpacesAndNewlines(e,t){for(;t<e.length&&i.isEmptySpaceOrNewLine(e[t]);)t++;return t}static isEmptySpaceOrNewLine(e){return" "==e||"\n"==e||"\t"==e||"\t\n"==e}}const r=i;class n{static isValid(e){return!(!e||!e.length)&&(r.isOperator(e[0])||"=="==e||"!="==e||"||"==e||"&&"==e||"<="==e||">="==e)}static chomp(e,t){if(!e||!e.length)return B.invalid();let s=r.pruneSpacesAndNewlines(e,t);if(e.length-s>=2){let t=["==","!=","||","&&","<=",">="];for(let i=0,r=t.length;i<r;i++)if(`${e[s]}${e[s+1]}`==t[i])return new B(t[i],s+2,n)}return r.isOperator(e[s])?new B(e[s],s+1,n):B.invalid()}static chompEqual(e,t){return t=r.pruneSpacesAndNewlines(e,t),!e||t>=e.length||"="!=e[t]?B.invalid():new B("=",t+1,n)}static chompOpenParanth(e,t){return(t=r.pruneSpacesAndNewlines(e,t))>=e.length||"("!=e[t]?B.invalid():new B("(",t+1,n)}static chompCloseParanth(e,t){return(t=r.pruneSpacesAndNewlines(e,t))>=e.length||")"!=e[t]?B.invalid():new B(")",t+1,n)}static chompOpenBracket(e,t){return(t=r.pruneSpacesAndNewlines(e,t))>=e.length||"{"!=e[t]?B.invalid():new B("{",t+1,n)}static chompCloseBracket(e,t){return(t=r.pruneSpacesAndNewlines(e,t))>=e.length||"}"!=e[t]?B.invalid():new B("}",t+1,n)}}const o=n;class h{static isValid(e){for(let t=0,s=e.length;t<s;t++)if(!r.isNumeric(e[t]))return!1;return!0}static chomp(e,t){if(!e||!e.length)return B.invalid();let s=r.pruneSpacesAndNewlines(e,t),i="";for(;s<e.length&&r.isNumeric(e[s]);)i+=e[s++];return i.length?new B(i,s,h):B.invalid()}}const a=h;class l{static chomp(e,t){let s=c.chomp(e,t);return s.isInvalid()?B.invalid():(s.type=l,s)}}class c{static isValid(e){if(!e.length)return!1;if(r.isNumeric(e[0]))return!1;for(let t=0,s=e.length;t<s;t++)if(!r.isAlpha(e[t])&&!r.isNumeric(e[t])&&"_"!=e[t])return!1;return!0}static isKeyword(e){return!!["auto","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","goto","if","int","long","register","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","volatile","while"].includes(e)}static chomp(e,t){if(!e||!e.length||r.isNumeric(e[t]))return B.invalid();let s=r.pruneSpacesAndNewlines(e,t),i="";for(;s<e.length&&(r.isAlpha(e[s])||r.isNumeric(e[s])||"_"==e[s]);)i+=e[s++];return i.length?c.isKeyword(i)?B.invalid():new B(i,s,c):B.invalid()}}class u{static keyWords(){return["int","char"]}}class d{static chomp(e,t){let s=d.chompKeywordsInitialization(e,t);if(s.isInvalid())return B.invalid();if((t=s.index)>=e.length||!r.isSeparator(e[t]))return B.invalid();t++;let i=c.chomp(e,t);if(i.isInvalid())return B.invalid();t=i.index;let n=new B(null,t,d);return n.childrenChomps=[s,i],n}static chompKeywordsInitialization(e,t){t=r.pruneSpacesAndNewlines(e,t);let s=u.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new B(s[i],t+s[i].length,u);return B.invalid()}}const g={VARIABLE_NOT_DEFINED:1,VARIABLE_MULTIPLE_DEFINITION:2,METHOD_NOT_DEFINED:3,WRONG_NUMBER_OF_PARAMETERS:4,NO_ERRORS:5,INVALID_RETURN:6,METHOD_MULTIPLE_DEFINITION:7,PREDEFINED_VALUE:8,MISSING_MAIN_METHOD:9,MULTIPLE_MAIN_METHODS:10,PARSE_ERROR:11,AMBIGUOS_DECLARATION:12,INVALID_VOID_EXPRESSION_USE:13};class p{constructor(e,t){this.buffer=e,this.type=t}static clean(){return new p(null,g.NO_ERRORS)}isClean(){return this.type==g.NO_ERRORS}toString(){for(const[e,t]of Object.entries(g))if(t==this.type)return e;return""}}class f{static chomp(e,t,s=!0){let i=f.chompDeclaration(e,t);if(t=i.index,s){if(t=r.pruneSpacesAndNewlines(e,t),!r.isAssignationEnding(e[t]))return B.invalid();i.index++}return i}static chompDeclaration(e,t){let s=f.chompInitializedVariable(e,t);if(s.isInvalid())return B.invalid();t=s.index;let i=V.chomp(e,t);if(i.isInvalid())return s;t=i.index;let r=new B("",t,f,!0);return r.childrenChomps=[s,i],r}static chompDeclarator(e,t){let s=M.chomp(e,t);if(!s.isInvalid())return s;let i=c.chomp(e,t);return i.isInvalid()?B.invalid():i}static chompInitializedVariable(e,t){let s=f.chompDeclarator(e,t);t=s.index;let i=o.chompEqual(e,t);return i.isInvalid()?B.invalid():(t=i.index,s.index=t,s)}static toString(e){let t="";const s=e.childrenChomps[0];switch(s.type){case c:t+=s.buffer;break;case M:t+=`*${s.childrenChomps[0].toString()}`}return t+="=",t+=e.childrenChomps[1].toString(),t+=";",t}static isAssignerDefined(e,t){switch(e.type){case c:return t.isVariableDefined(e.buffer);case M:return V.checkStackInitialization(e.childrenChomps[0],t)}return!1}static findUnassignedVariables(e,t){let s=e.childrenChomps,i=s[0],r=s[1],n=[];if(f.isAssignerDefined(i,t)||n.push(i),n.length)return new p(null,g.VARIABLE_NOT_DEFINED);let o=V.checkStackInitialization(r,t);return o.isClean()?p.clean():o}}class m{static searchChompByType(e,t){let s=[];return m.searchChompByType_t(e,t,s),s}static chompToDictionary(e){const t={};return Object.keys(e).forEach((s=>{t[s]=e[s]})),t}static searchChompByType_t(e,t,s){let i=m.chompToDictionary(e),r=!0;for(const[e,s]of Object.entries(t))if(e in i&&s!=i[e]){r=!1;break}r&&s.push(e);let n=e.childrenChomps;for(let e=0,i=n.length;e<i;e++)m.searchChompByType_t(n[e],t,s)}}class b{static keyWords(){return["int","char"]}}class R{}class I{static isValid(e){let t=0,s=I.chompDeclarationHeader(e,t);if(s.isInvalid())return!1;for(t=s.index;t<e.length;){let s=I.chompDeclaration(e,t);if(s.isInvalid())break;t=s.index,r.isCommaSeparator(e[t])&&t++}return!!r.isAssignationEnding(e[t])}static chomp(e,t){let s=[],i=I.chompDeclarationHeader(e,t);if(i.isInvalid())return B.invalid();for(s.push(i),t=i.index;t<e.length;){let i=I.chompDeclaration(e,t);if(i.isInvalid())break;s.push(i),t=i.index,t=r.pruneSpacesAndNewlines(e,t),r.isCommaSeparator(e[t])&&t++}if(t=r.pruneSpacesAndNewlines(e,t),!r.isAssignationEnding(e[t]))return B.invalid();let n=new B(null,t+1,I,!0);return n.childrenChomps=s,n}static chompDeclaration(e,t){let s=I.chompInitializedVariable(e,t);if(s.isInvalid())return B.invalid();t=s.index;let i=V.chomp(e,t);if(i.isInvalid()){let e=new B(null,t,R,!0);return e.childrenChomps=[s],e}t=i.index;let r=new B(null,t,R,!0);return r.childrenChomps=[s,i],r}static chompDeclarationHeader(e,t){let s=I.chompKeywordsInitialization(e,t);return s.isInvalid()?s:(t=s.index,r.isSeparator(e[t])?(s.index=t+1,s):B.invalid())}static chompInitializedVariable(e,t){let s=c.chomp(e,t);if(s.isInvalid())return B.invalid();t=s.index;let i=o.chompEqual(e,t);return i.isInvalid()?s:(t=i.index,new B(s.buffer,t,c))}static chompKeywordsInitialization(e,t){t=r.pruneSpacesAndNewlines(e,t);let s=b.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new B(s[i],t+s[i].length,b);return B.invalid()}static displayComponent(e){let t="",s=e.childrenChomps;t+=s[0].buffer+"=";for(let e=1,i=s.length;e<i;e++)s[e].type!=V?t+=s[e].buffer:t+=s[e].toString();return t}static display(e){if(e.isInvalid())return"Invalid!";let t=[];t.push(e.childrenChomps[0].buffer);let s=e.childrenChomps;for(let e=1,i=s.length;e<i;e++)t.push(I.displayComponent(s[e]));return t.join(" -> ")}static initializeVariable(e,t){let s=m.searchChompByType(e,{type:c});for(let e=0,i=s.length;e<i;e++)t.push(s[e].buffer)}static hasVariableAlreadyBeenDefined(e,t){let s=m.searchChompByType(e,{type:c});for(let e=0,i=s.length;e<i;e++)if(t.isVariableDefined(s[e].buffer))return!0;return!1}static addToStackAndVerify(e,t){let s=m.searchChompByType(e,{type:R});for(let e=0,i=s.length;e<i;e++){let i=s[e].childrenChomps,r=i[0];if(I.hasVariableAlreadyBeenDefined(r,t))return new p([r.buffer],g.VARIABLE_MULTIPLE_DEFINITION);if(I.initializeVariable(r,t),i.length>1){let e=i[1],s=V.checkStackInitialization(e,t);if(!s.isClean())return s}}return p.clean()}}class k{static keyWords(){return["while","for"]}}class S{static chomp(e,t,s=!1){let i=S.chompKeywordsInitialization(e,t);return i.isInvalid()?B.invalid():(t=i.index,"while"==i.buffer?S.chompWhileBlock(e,t,s):"for"==i.buffer?S.chompForBlock(e,t,s):B.invalid())}static chompKeywordsInitialization(e,t){t=r.pruneSpacesAndNewlines(e,t);let s=k.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new B(s[i],t+s[i].length,k);return B.invalid()}static chompWhileBlock(e,t,s){let i=o.chompOpenParanth(e,t);if(i.isInvalid())return B.invalid();t=i.index;let r=V.chomp(e,t);if(r.isInvalid())return B.invalid();t=r.index;let n=o.chompCloseParanth(e,t);if(n.isInvalid())return B.invalid();t=n.index;let h=T.chomp(e,t,s);if(h.isInvalid())return B.invalid();t=h.index;let a=new B("while",t,S);return a.childrenChomps=[r,h],a}static chompForBlock(e,t,s){let i=o.chompOpenParanth(e,t);if(i.isInvalid())return B.invalid();t=i.index;let n=S.chompForInitialization(e,t);if(n.isInvalid())return B.invalid();t=n.index;let h=V.chomp(e,t);if(h.isInvalid())return B.invalid();if((t=h.index)>=e.length||!r.isAssignationEnding(e[t]))return B.invalid();t++;let a=f.chomp(e,t,!1);if(a.isInvalid())return B.invalid();t=a.index;let l=o.chompCloseParanth(e,t);if(l.isInvalid())return B.invalid();t=l.index;let c=T.chomp(e,t,s);if(c.isInvalid())return B.invalid();t=c.index;let u=new B("for",t,S);return u.childrenChomps=[n,h,a,c],u}static chompForInitialization(e,t){let s=[f.chomp,I.chomp];for(let i=0;i<s.length;i++){let r=s[i](e,t);if(!r.isInvalid())return r}return B.invalid()}static addToStackAndVerify_While(e,t){const s=e.childrenChomps;let i=s[0],r=V.checkStackInitialization(i,t);if(!r.isClean())return r;if(s.length<2)return p.clean();let n=s[1];return T.addToStackAndVerify(n,t)}static addToStackAndVerify_For(e,t){const s=e.childrenChomps;let i=s[0],r=s[1],n=s[2];switch(i.type){case f:{let e=f.findUnassignedVariables(i,t);if(!e.isClean())return e;break}case I:{let e=I.addToStackAndVerify(i,t);if(!e.isClean())return e;break}}const o=V.checkStackInitialization(r,t);if(!o.isClean())return o;const h=V.checkStackInitialization(n,t);if(!h.isClean())return h;if(s.length<=3)return p.clean();const a=s[3];return T.addToStackAndVerify(a,t)}static addToStackAndVerify(e,t){switch(e.buffer){case"while":return S.addToStackAndVerify_While(e,t);case"for":{t.freeze();let s=S.addToStackAndVerify_For(e,t);return t.pop(),s}}return p.clean()}}class v{static keyWords(){return["if"]}}class y{static chomp(e,t,s=!1){let i=y.chompKeywordsInitialization(e,t);if(i.isInvalid())return B.invalid();t=i.index;let r=o.chompOpenParanth(e,t);if(r.isInvalid())return B.invalid();t=r.index;let n=V.chomp(e,t);if(n.isInvalid())return B.invalid();t=n.index;let h=o.chompCloseParanth(e,t);if(h.isInvalid())return B.invalid();t=h.index;let a=T.chomp(e,t,s);if(a.isInvalid())return B.invalid();t=a.index;let l=new B(null,t,y);return l.childrenChomps=[n,a],l}static chompKeywordsInitialization(e,t){t=r.pruneSpacesAndNewlines(e,t);let s=v.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new B(s[i],t+s[i].length,v);return B.invalid()}static addToStackAndVerify(e,t){let s=e.childrenChomps;const i=s[0],r=s[1];let n=V.checkStackInitialization(i,t);return n.isClean()?T.addToStackAndVerify(r,t):n}}class T{static chomp(e,t,s=!1){let i=o.chompOpenBracket(e,t);if(i.isInvalid())return B.invalid();t=i.index;let r=T.chompBlock(e,t,s);t=r.index;let n=o.chompCloseBracket(e,t);if(n.isInvalid())return B.invalid();t=n.index;let h=new B(null,t,T);return h.childrenChomps=r.childrenChomps,h}static expressionChompWithLineTerminator(e,t){let s=V.chomp(e,t);return s.isInvalid()||(t=s.index)>=e.index||!r.isAssignationEnding(e[t])?B.invalid():(s.index++,s)}static chompBlock(e,t,s){let i=[f.chomp,I.chomp,(e,t)=>T.chomp(e,t,s),(e,t)=>S.chomp(e,t,s),(e,t)=>y.chomp(e,t,s)];s&&i.push(N.chomp),i.push(T.expressionChompWithLineTerminator);let r=[];for(;t<e.length;){let s=!1;for(let n=0;n<i.length;n++){let o=i[n](e,t);if(!o.isInvalid()){t=o.index,s=!0,r.push(o);break}}if(!s)break}let n=new B(null,t,T);return n.childrenChomps=r,n}static addToStackAndVerify_t(e,t){let s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++){let i=s[e];switch(i.type){case f:{let e=f.findUnassignedVariables(i,t);if(!e.isClean())return e;break}case I:{let e=I.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case T:{let e=T.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case S:{let e=S.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case y:{let e=y.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case E:{let e=N.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case V:{let e=V.checkStackInitialization(i,t);if(!e.isClean())return e;break}}}return p.clean()}static addToStackAndVerify(e,t){t.freeze();let s=T.addToStackAndVerify_t(e,t);return t.pop(),s}}class A{static keyWords(){return["int","void","char"]}}class w{static findUnassignedVariables(e,t){let s=e.childrenChomps[1].childrenChomps;for(let e=0,i=s.length;e<i;e++){let i=V.checkStackInitialization(s[e],t);if(!i.isClean())return i}return p.clean()}static doesMethodHaveAllTheParametersPresent(e,t){let s=e.childrenChomps,i=s[0].buffer,r=s[1].childrenChomps;const n=t.getArgsFromMethodName(i);return!n||n.length!=r.length}}class _{}class E{}class C{}class N{static keyWords(){return["return"]}static chompReturnWithExpression(e,t){let s=V.chomp(e,t);if(s.isInvalid())return B.invalid();if(t=s.index,(t=r.pruneSpacesAndNewlines(e,t))>=e.length||!r.isAssignationEnding(e[t]))return B.invalid();t++;let i=new B(null,t,E);return i.childrenChomps=[s],i}static chompReturnWithoutExpression(e,t){if((t=r.pruneSpacesAndNewlines(e,t))>=e.length||!r.isAssignationEnding(e[t]))return B.invalid();t++;let s=new B(null,t,C);return s.childrenChomps=[],s}static chomp(e,t,s=!0){let i=N.chompKeywordsInitialization(e,t);if(i.isInvalid())return B.invalid();if((t=i.index)>=e.length||!r.isSeparator(e[t]))return B.invalid();t++;const n=N.chompReturnWithExpression(e,t);if(!n.isInvalid())return n;const o=N.chompReturnWithoutExpression(e,t);return o.isInvalid()?B.invalid():o}static chompKeywordsInitialization(e,t){t=r.pruneSpacesAndNewlines(e,t);let s=N.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new B(s[i],t+s[i].length,A);return B.invalid()}static addToStackAndVerify(e,t){const s=e.childrenChomps[0];return V.checkStackInitialization(s,t)}}class D{static chompDeclaration(e,t){let s=D.methodHeaderDeclaration(e,t);if(s.isInvalid())return B.invalid();t=s.index;let i=o.chompOpenParanth(e,t);if(i.isInvalid())return B.invalid();t=i.index;let r=D.chompMethodDeclarationsAnthetParams(e,t);if(r.isInvalid())return B.invalid();t=r.index;let n=o.chompCloseParanth(e,t);if(n.isInvalid())return B.invalid();t=n.index;let h=T.chomp(e,t,!0);if(h.isInvalid())return B.invalid();t=h.index;let a=new B(s.buffer,t,D);return a.childrenChomps=[s,r,h],a}static chompMethodCall(e,t){let s=l.chomp(e,t);if(s.isInvalid())return B.invalid();t=s.index;let i=o.chompOpenParanth(e,t);if(i.isInvalid())return B.invalid();t=i.index;let r=D.chompMethodParameters(e,t);if(r.isInvalid())return B.invalid();t=r.index;let n=o.chompCloseParanth(e,t);if(n.isInvalid())return B.invalid();t=n.index;let h=new B(null,t,w);return h.childrenChomps=[s,r],h}static chompKeywordsInitialization(e,t){t=r.pruneSpacesAndNewlines(e,t);let s=A.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new B(s[i],t+s[i].length,A);return B.invalid()}static chompMethodParameters(e,t){let s=[],i=!1;for(;t<e.length;){let n=V.chomp(e,t),o=n.isInvalid();if(!i&&o)return D.arrayToChomp(s,t);if(o)return B.invalid();if(i=!0,t=n.index,s.push(n),(t=r.pruneSpacesAndNewlines(e,t))>=e.length||!r.isCommaSeparator(e[t]))return D.arrayToChomp(s,t);t++}return D.arrayToChomp(s,t)}static methodHeaderDeclaration(e,t){let s=D.chompKeywordsInitialization(e,t);if(s.isInvalid())return B.invalid();if((t=s.index)>=e.length||!r.isSeparator(e[t]))return B.invalid();t++;let i=l.chomp(e,t);if(i.isInvalid())return B.invalid();t=i.index;let n=new B(i.buffer,t,_);return n.childrenChomps=[s,i],n}static methodName(e){return e.type!=D?null:e.childrenChomps[0].buffer}static arrayToChomp(e,t){let s=new B(null,t);return s.childrenChomps=e,s}static chompMethodDeclarationsAnthetParams(e,t){let s=[],i=!1;for(;t<e.length;){let n=d.chomp(e,t);if(!i&&n.isInvalid())return D.arrayToChomp(s,t);if(s.push(n),i=!0,(t=n.index)>=e.length||!r.isCommaSeparator(e[t]))return D.arrayToChomp(s,t);t++}return D.arrayToChomp(s,t)}static searchMethodByName(e,t){return m.searchChompByType(e,{buffer:t,type:D})}static searchAllMethods(e){return m.searchChompByType(e,{type:D})}static pushMethodParams(e,t,s){const i=t.childrenChomps;let r=[];for(let e=0,t=i.length;e<t;e++){const t=i[e].childrenChomps[0],s=i[e].childrenChomps[1];r.push({type:t,name:s})}s.pushMethod(e,r)}static checkParamsAndPush(e,t){const s=e.childrenChomps;let i=[];for(let e=0,r=s.length;e<r;e++){const r=s[e].childrenChomps[1].buffer;t.isVariableDefined(r)&&i.push(r)}return i}static pushParams(e,t){const s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++){const i=s[e].childrenChomps[1];t.push(i.buffer)}}static doesReturnNeedsToBeNonVoid(e){const t=m.searchChompByType(e,{type:E}),s=m.searchChompByType(e,{type:C});return!(!t.length||s.length)}static doesReturnNeedsToBeVoid(e){return!m.searchChompByType(e,{type:E}).length}static doesReturnNeedsToBe(e,t){return"void"==e?D.doesReturnNeedsToBeVoid(t):"void"==e||D.doesReturnNeedsToBeNonVoid(t)}static isMethodVoid(e){let t=e.childrenChomps[0];return"void"==m.searchChompByType(t,{type:A})[0].buffer}static addDefaultReturn(e){e.childrenChomps[2].childrenChomps.push(new B(null,0,C))}static addDefaultReturnsForVoidMethods(e){let t=m.searchChompByType(e,{type:D});for(let e=0,s=t.length;e<s;e++)"main"!=t[e].buffer&&D.isMethodVoid(t[e])&&D.addDefaultReturn(t[e])}static addToStackAndVerify(e,t){let s=e.childrenChomps;const i=s[0],r=s[1],n=s[2],o=i.childrenChomps[1],h=i.childrenChomps[0].buffer;if(t.isMethodDefined(o.buffer)||t.isVariableDefined(o.buffer))return new p([o.buffer],g.VARIABLE_MULTIPLE_DEFINITION);let a=D.checkParamsAndPush(r,t);if(a.length)return new p(a,g.VARIABLE_MULTIPLE_DEFINITION);if(!D.doesReturnNeedsToBe(h,n))return new p(null,g.INVALID_RETURN);D.pushMethodParams(o.buffer,r,t),t.freeze(),D.pushParams(r,t);let l=T.addToStackAndVerify(n,t);return l.isClean()?(t.pop(),p.clean()):l}}class ${static isValid(e){let t=[0],s=[];if($.denominator_Chomp(e,t,s).isInvalid())return!1;for(;t<e.length;){if($.operator_Chomp(e,t,s).isInvalid())return!1;if($.denominator_Chomp(e,t,s).isInvalid())return!1}return!0}static operator_Chomp(e,t,s){let i=o.chomp(e,t[0]);return i.isInvalid()?B.invalid():(s.push(i),t[0]=i.index,i)}static denominator_Chomp(e,t,s){let i=$.chompDenominator(e,t[0]);if(i.isInvalid()){let i=[t[0]],r=$.chomp_ParanthesisData(e,i[0]);return r.isInvalid()||(s.push(r),t[0]=r.index),r}return s.push(i),t[0]=i.index,i}static chompFromArray(e,t){let s=new B(null,t[0],$,!0);return s.childrenChomps=e,s}static chompSearch_t(e,t){let s=[t],i=[];if($.denominator_Chomp(e,s,i).isInvalid())return B.invalid();for(;s<e.length;){if($.operator_Chomp(e,s,i).isInvalid())return $.chompFromArray(i,s);if($.denominator_Chomp(e,s,i).isInvalid())return B.invalid()}return $.chompFromArray(i,s)}static chomp(e,t){for(let s=e.length-1;s>=t;s--){let i=$.chompSearch_t(e.substring(t,s+1),0);if(!i.isInvalid())return i.index+=t,i}return B.invalid()}static chomp_ParanthesisData(e,t){let s=o.chompOpenParanth(e,t);if(s.isInvalid())return B.invalid();t=s.index;let i=$.chompSearch_t(e,t);if(i.isInvalid())return B.invalid();t=i.index;let r=o.chompCloseParanth(e,t);return r.isInvalid()?B.invalid():(t=r.index,$.chompFromArray(i.childrenChomps,[t]))}static chompDenominator(e,t){let s=[D.chompMethodCall,M.chomp,a.chomp,c.chomp];for(let i=0,r=s.length;i<r;i++){let r=s[i](e,t);if(!r.isInvalid())return r}return B.invalid()}static checkStackInitialization_t(e,t){const s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++)switch(s[e].type){case c:if(!t.isVariableDefined(s[e].buffer))return new p([s[e].buffer],g.VARIABLE_NOT_DEFINED);break;case M:{let i=M.findUnassignedVariables(s[e],t);if(!i.isClean())return i;break}case $:$.checkStackInitialization_t(s[e],t);break;case w:{let i=w.findUnassignedVariables(s[e],t);if(!i.isClean())return i;if(w.doesMethodHaveAllTheParametersPresent(s[e],t))return new p("Wrong number of arguments of method!",g.WRONG_NUMBER_OF_PARAMETERS);break}}return p.clean()}static checkStackInitialization(e,t){return $.checkStackInitialization_t(e,t)}}const V=$;class M{static chomp(e,t){if(!e||t>=e.length)return B.invalid();if("*"!=e[t=r.pruneSpacesAndNewlines(e,t)])return B.invalid();t++;let s=c.chomp(e,t);if(!s.isInvalid()){t=s.index;let e=new B(null,t,M);return e.childrenChomps=[V.chomp(s.buffer,0)],e}let i=V.chomp_ParanthesisData(e,t);if(i.isInvalid())return B.invalid();t=i.index;let n=new B(null,t,M);return n.childrenChomps=[i],n}static findUnassignedVariables(e,t){const s=e.childrenChomps[0];return V.checkStackInitialization(s,t)}}let x=0;class O{constructor(e,t,s=null,i=!1,r=!1){this.buffer=e,this.index=t,this.invalid=r,this.type=s,this.childrenChomps=[],this.isParent=i,this.parentChomp=null,this.id=x++,this.ignore=!1,this.expressionTree=null}static invalid(){return new O(-1,-1,null,!1,!0)}pushChild(e){this.childrenChomps.push(e)}isInvalid(){return this.invalid}toString(e=0){if(this.isParent){let t="";for(let s=0,i=this.childrenChomps.length;s<i;s++)t+=this.childrenChomps[s].toString(e+1);return e?`(${t})`:t}return this.type===M?`*${this.childrenChomps[0].toString()}`:this.buffer}}const B=O;class P{constructor(){this.index=[0],this.variables=[],this.methods=[]}push(e){this.variables.push({type:"variable",value:e})}pushMethod(e,t){this.methods.push({type:"method",value:e,params:t})}getArgsFromMethodName(e){for(let t=0,s=this.methods.length;t<s;t++)if("method"==this.methods[t].type&&e==this.methods[t].value)return this.methods[t].params;return null}isMethodDefined(e){for(let t=0,s=this.methods.length;t<s;t++)if("method"==this.methods[t].type&&e==this.methods[t].value)return!0;return!1}isVariableDefined(e){for(let t=0,s=this.variables.length;t<s;t++)if("variable"==this.variables[t].type&&e==this.variables[t].value)return!0;return!1}top(){return this.variables[this.variables.length-1].value}freeze(){this.index.push(this.variables.length)}pop(){if(this.index.length){for(let e=this.variables.length-1;e>=this.index[this.index.length-1];e--)this.variables.pop();this.index.pop()}}}class z{static methods(e){return`${z.getElementAt()}${z.storeElement()}${z.storePrint(e)}${z.bytePrint(e)}`}static getElementAt(){return"int getElement(int buffer,int pos){return *(buffer+pos*4);}"}static storeElement(){return"int setElement(int buffer,int pos,int element){*(buffer+pos*4)=element;return 0;}"}static bytePrint(e){return`\n    int __digitCount(int n) {\n      int total = 0;\n      while(n) {\n        n = n / 10;\n        total = total + 1;\n      }\n\n      return total;\n    }\n\n    int pushCharacter(int character) {\n      int stdoutBuffer = ${e};\n      int currentOffset = *(stdoutBuffer - 4);\n      *(stdoutBuffer + currentOffset) = character;\n      *(stdoutBuffer - 4) = currentOffset + 1;\n      return 0;\n    }\n    \n    int printNumber_t(int element){\n      if(element == 0) {\n        return 0;\n      }\n      printNumber_t(element / 10);\n      pushCharacter(element % 10 + 48);\n      return 0;\n    }\n\n    int printChar(int element){\n      return pushCharacter(element);\n    }\n    \n    int printNumber(int element){\n      if(element < 0) {\n        element = 0 - element;\n        printChar(45);\n        return printNumber_t(element);\n      }\n      if(element == 0) {\n        printChar(48);\n      }\n      return printNumber_t(element);\n    }\n    `}static storePrint(e){return`int printLine(int element){int startingPointer=${e};int size=*(startingPointer-4);*(startingPointer+size)=element;*(startingPointer-4)=size+4;return 0;}`}}class L{constructor(e,t=[],s=!0,i=65536){this.code=s?`${z.methods(i)}${e}`:e,this.errors=t}fillParents(e){for(let t=0,s=e.childrenChomps.length;t<s;t++)e.childrenChomps[t].parentChomp=e,this.fillParents(e.childrenChomps[t])}chomp(){let e=this._chomp(this.code,0);return this.fillParents(e),e.isInvalid()?(this.errors.push(new p(null,g.PARSE_ERROR)),B.invalid()):this.validateChomp(e)?(this.ignoreUnusedMethods(e),e):B.invalid()}validateChomp(e){let t=D.searchMethodByName(e,"main");return t.length?t.length>1?(this.errors.push(new p(null,g.MULTIPLE_MAIN_METHODS)),!1):!(!this.validateMethodsUniqueness(e)||!this.validateVariableNonKeywords(e)||!this.validateStackVariables(e)||(this.validateMethodNoVariables(e)?!this.validateVoidMethodsInExpressions(e)&&(this.errors.push(new p(null,g.INVALID_VOID_EXPRESSION_USE)),1):(this.errors.push(new p(null,g.AMBIGUOS_DECLARATION)),1))):(this.errors.push(new p(null,g.MISSING_MAIN_METHOD)),!1)}pairVoidMethods(e){let t={},s=m.searchChompByType(e,{type:D});for(let e=0,i=s.length;e<i;e++)"main"!=s[e].buffer&&D.isMethodVoid(s[e])&&(t[s[e].buffer]=1);return t}doesExpressionHaveMethod(e,t){let s=m.searchChompByType(e,{type:w});for(let e=0,i=s.length;e<i;e++)if(s[e].childrenChomps[0].buffer in t)return!0;return!1}doesNodeHaveMethod(e,t){let s=m.searchChompByType(e,{type:V});for(let e=0,i=s.length;e<i;e++)if(this.doesExpressionHaveMethod(s[e],t))return!0;return!1}doMethodHasVoidCalls(e,t){let s=m.searchChompByType(e,{type:w});for(let e=0,i=s.length;e<i;e++)if(s[e].childrenChomps[0].buffer in t)return!0;return!1}expressionsVoidMethods(e,t){let s=m.searchChompByType(e,{type:w});for(let e=0,i=s.length;e<i;e++)if(s[e].childrenChomps[0].buffer in t&&s[e].parentChomp.childrenChomps.length>1||this.doMethodHasVoidCalls(s[e].childrenChomps[1],t))return!1;return!0}validateVoidMethodsInExpressions(e){let t=this.pairVoidMethods(e),s=m.searchChompByType(e,{type:I});for(let e=0,i=s.length;e<i;e++)if(this.doesNodeHaveMethod(s[e],t))return!1;let i=m.searchChompByType(e,{type:f});for(let e=0,s=i.length;e<s;e++)if(this.doesNodeHaveMethod(i[e],t))return!1;return!!this.expressionsVoidMethods(e,t)}validateVariableNonKeywords(e){let t=m.searchChompByType(e,{type:c});const s=["auto","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","goto","if","int","long","register","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","volatile","while"];for(let e=0,i=t.length;e<i;e++)if(s.includes(t[e].buffer))return this.errors.push(new p(t[e].buffer,g.PREDEFINED_VALUE)),!1;return!0}ignoreUnusedMethods_t(e,t,s){const i=t[e];let r=m.searchChompByType(i,{type:w});for(let e=0,i=r.length;e<i;e++){const i=r[e].childrenChomps[0].buffer;i in s||(s[i]=1,this.ignoreUnusedMethods_t(i,t,s))}}pairMethodsWithNames(e){let t={},s=m.searchChompByType(e,{type:D});for(let e=0,i=s.length;e<i;e++)t[D.methodName(s[e])]=s[e];return t}ignoreUnusedMethods(e){let t=this.pairMethodsWithNames(e),s={main:1};this.ignoreUnusedMethods_t("main",t,s);for(const[e,i]of Object.entries(t))e in s||(i.ignore=!0)}compilationError(){return 0==this.errors.length}errorsToString(){let e=[];for(let t=0,s=this.errors.length;t<s;t++)e.push(this.errors[t].toString());return e.join(", ")}validateMethodsUniqueness(e){let t=D.searchAllMethods(e),s={};for(let e=0,i=t.length;e<i;e++)if(t[e].buffer in s||(s[t[e].buffer]=0),s[t[e].buffer]++,s[t[e].buffer]>1)return this.errors.push(new p(t[e].buffer,g.METHOD_MULTIPLE_DEFINITION)),!1;return!0}validateMethodNoVariables(e){let t=D.searchAllMethods(e),s=m.searchChompByType(e,{type:c}),i={};for(let e=0,t=s.length;e<t;e++)i[s[e].buffer]=1;for(let e=0,s=t.length;e<s;e++)if(t[e].buffer in i)return!1;return!0}validateStackVariables(e){return this.validateStackVariables_t(e,new P)}validateStackVariables_t(e,t){let s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++){const i=s[e];switch(i.type){case f:{const e=f.findUnassignedVariables(i,t);if(!e.isClean())return this.errors.push(e),!1;break}case I:{const e=I.addToStackAndVerify(i,t);if(!e.isClean())return this.errors.push(e),!1;break}case D:{const e=D.addToStackAndVerify(i,t);if(!e.isClean())return this.errors.push(e),!1;break}}}return!0}_chomp(e,t){let s=[D.chompDeclaration],i=[];for(;t<e.length;){let r=!1;for(let n=0,o=s.length;n<o;n++){let o=s[n](e,t);if(!o.isInvalid()){i.push(o),r=!0,t=o.index;break}}if(!r)break}if((t=r.pruneSpacesAndNewlines(e,t))<e.length)return B.invalid();let n=new B(null,t,L);return n.childrenChomps=i,D.addDefaultReturnsForVoidMethods(n),n}}class G{constructor(e){this.instructionArray=e,this.register={},this.initialStackPointer=524288,this.stackPointer=this.initialStackPointer,this.memory=new Array(1048576).fill(0),this.addresses={},this.outputBuffer="",this.pc=0,this.instructionCounter={},this.saveLabelAddresses()}getStdoutResponse(){let e=[];for(let t=0,s=this.getNumberAtAddress(this.memory,65532);t<s;t+=4)e.push(this.getNumberAtAddress(this.memory,65536+t));return e.join("\n")}getRawStdoutBuffer(){const e=this.getNumberAtAddress(this.memory,65532);let t="";for(let s=0;s<e;s++)t+=String.fromCharCode(this.memory[s+65536]);return t}get32BitNumberAtAddress(e){return this.getNumberAtAddress(this.memory,e)}saveRegValue(e,t){let s=t.toString(),i=e.toString();s in this.register&&(this.register[i]=this.register[s])}saveLabelAddresses(){for(let e=0,t=this.instructionArray.length;e<t;e++){const t=this.instructionArray[e];t instanceof he&&(this.addresses[t.label]=e)}}currentStackPointer(){return this.stackPointer}getRegValue(e){const t=e.toString();return t in this.register?parseInt(this.register[t]):0}printPointerBytes(e){let t=[];for(let s=0;s<e;s++)t.push(this.memory[this.stackPointer+s]);return t.join(" ")}positiveNumberToByteArray(e){const t=[0,0,0,0];return t[0]=255&e,t[1]=e>>8&255,t[2]=e>>16&255,t[3]=e>>24&255,t}negativeNumberToByteArray(e){const t=2**32+e;return this.positiveNumberToByteArray(t)}numberToByteArray(e){return e>=0?this.positiveNumberToByteArray(e):this.negativeNumberToByteArray(e)}saveRegInStack(e,t){let s=this.numberToByteArray(this.getRegValue(t)),i=parseInt(e);for(let e=0,t=s.length;e<t;e++)this.memory[this.stackPointer-i+e]=s[e]}saveRegInMem(e,t){let s=this.numberToByteArray(this.getRegValue(t)),i=parseInt(e);for(let e=0,t=s.length;e<t;e++)this.memory[i+e]=s[e]}get32ByteInteger(e){return e<2**31?e:-(2**32-e)}getNumberAtAddress(e,t,s=1){switch(s){case 1:{let s=0,i=1;for(let r=0;r<4;r++)s+=e[t+r]*i,i*=256;return this.get32ByteInteger(s)}case 2:return e[t]}return 0}saveMemInReg(e,t){this.register[t.toString()]=this.getNumberAtAddress(this.memory,parseInt(e))}saveStackInReg(e,t){this.register[t]=this.getNumberAtAddress(this.memory,this.stackPointer-parseInt(e))}saveRegMemInReg(e,t){this.register[t.toString()]=this.getNumberAtAddress(this.memory,parseInt(this.register[e.toString()]))}saveRegInMemReg(e,t){let s=this.numberToByteArray(this.getRegValue(e)),i=this.getRegValue(t);for(let e=0,t=s.length;e<t;e++)this.memory[i+e]=s[e]}numberFromPointer(e){return this.getNumberAtAddress(this.memory,e)}runMov(e){switch(e.type){case W.REG_TO_REG:this.saveRegValue(e.dst,e.src);break;case W.REG_TO_STACK:this.saveRegInStack(e.dst,e.src);break;case W.NUMBER_TO_REG:this.register[e.dst.toString()]=parseInt(e.src);break;case W.REG_TO_MEM:this.saveRegInMem(e.dst,e.src);break;case W.MEM_TO_REG:this.saveMemInReg(e.src,e.dst);break;case W.STACK_TO_REG:this.saveStackInReg(e.src,e.dst);break;case W.REG_MEM_TO_REG:this.saveRegMemInReg(e.src,e.dst);break;case W.REG_TO_MEM_REG:this.saveRegInMemReg(e.src,e.dst)}}runPush(e){this.saveRegInStack(0,e.register),this.stackPointer+=4}runPop(e){this.stackPointer-=parseInt(e.bytes)}jumpAtRegisterLabel(e){this.pc=this.getRegValue(e)-1}runJump(e){switch(e.type){case ae.LABEL:this.pc=this.addresses[e.value];break;case ae.REGISTER:this.jumpAtRegisterLabel(e.value)}}runAdd(e){this.register[e.dst.toString()]=this.getRegValue(e.b)+this.getRegValue(e.c)}runMul(e){this.register[e.dst.toString()]=this.getRegValue(e.b)*this.getRegValue(e.c)}runSub(e){this.register[e.dst.toString()]=this.getRegValue(e.b)-this.getRegValue(e.c)}runMul(e){this.register[e.dst.toString()]=this.getRegValue(e.b)*this.getRegValue(e.c)}runDivAndMod(e){this.register.HI=this.getRegValue(e.a)%this.getRegValue(e.b),this.register.LO=Math.floor(this.getRegValue(e.a)/this.getRegValue(e.b))}runPrp(e){this.register[e.reg.toString()]=this.pc+e.offset}booleanToNumber(e){return e?1:0}runCmp(e){this.register._setGe=this.booleanToNumber(this.getRegValue(e.regA)>=this.getRegValue(e.regB)),this.register._setE=this.booleanToNumber(this.getRegValue(e.regA)==this.getRegValue(e.regB)),this.register._setNe=this.booleanToNumber(this.getRegValue(e.regA)!=this.getRegValue(e.regB)),this.register._setLe=this.booleanToNumber(this.getRegValue(e.regA)<=this.getRegValue(e.regB)),this.register._setNz=this.booleanToNumber(this.getRegValue(e.regA)&&this.getRegValue(e.regB)),this.register.CF=this.booleanToNumber(this.getRegValue(e.regA)<this.getRegValue(e.regB)),this.register.CT=this.booleanToNumber(this.getRegValue(e.regA)>this.getRegValue(e.regB))}setGe(e){this.register[e.regA.toString()]=this.register._setGe}setE(e){this.register[e.regA.toString()]=this.register._setE}setNe(e){this.register[e.regA.toString()]=this.register._setNe}setNz(e){this.register[e.regA.toString()]=this.register._setNz}setLe(e){this.register[e.regA.toString()]=this.register._setLe}setTest(e){this.register.zero_reg=this.booleanToNumber(this.getRegValue(e.regA)&&this.getRegValue(e.regB))}setJz(e){"zero_reg"in this.register&&!this.register.zero_reg&&(this.pc=this.addresses[e.label])}setOr(e){this.register.or_reg=this.booleanToNumber(this.getRegValue(e.regA)||this.getRegValue(e.regB))}setDor(e){this.register[e.reg.toString()]=this.register.or_reg}setPrint(e){switch(e.type){case de.REGISTER:this.outputBuffer+=this.getRegValue(e.value);break;case de.MEMORY:this.outputBuffer+=this.numberFromPointer(parseInt(e.value)+this.initialStackPointer)}}addInstructionToStatistics(e){const t=e.constructor.name;t in this.instructionCounter||(this.instructionCounter[t]=0),this.instructionCounter[t]++}runInstruction(e){e instanceof K&&this.runMov(e),e instanceof X&&this.runPush(e),e instanceof Y&&this.runPop(e),e instanceof le&&this.runJump(e),e instanceof j&&this.runAdd(e),e instanceof ce&&this.runDivAndMod(e),e instanceof J&&this.runSub(e),e instanceof q&&this.runMul(e),e instanceof ue&&this.runPrp(e),e instanceof Z&&this.runCmp(e),e instanceof re&&this.setGe(e),e instanceof ee&&this.setE(e),e instanceof Q&&this.setNe(e),e instanceof se&&this.setNz(e),e instanceof ne&&this.setLe(e),e instanceof te&&this.setTest(e),e instanceof oe&&this.setJz(e),e instanceof ge&&this.setPrint(e),e instanceof ie&&this.setOr(e),e instanceof H&&this.setDor(e)}getOutputBuffer(){return this.outputBuffer}statistics(){let e=0,t=[];for(const[t,s]of Object.entries(this.instructionCounter))e+=s;for(const[s,i]of Object.entries(this.instructionCounter))e&&t.push(`${s}: ${i/e*100}`);return t.join("\n")}run(){for(this.pc=0;this.pc<this.instructionArray.length;this.pc++)this.runInstruction(this.instructionArray[this.pc])}}class F{constructor(){this.block=[],this.runner=null}toString_t(e){return e instanceof F?this.toStringArray_t(e.block):[e.toString()]}getStdoutResponse(){return this.runner.getStdoutResponse()}getRawStdoutBuffer(){return this.runner.getRawStdoutBuffer()}toStringArray_t(e){let t=[];for(let s=0,i=e.length;s<i;s++){let i=this.toString_t(e[s]);for(let e=0,s=i.length;e<s;e++)t.push(i[e])}return t}toStringArray(){return this.toStringArray_t(this.block)}toString(){return this.toStringArray_t(this.block).join("\n")}push(e){this.block.push(e)}flatten_t(e,t){if(e instanceof F)for(let s=0,i=e.block.length;s<i;s++)this.flatten_t(e.block[s],t);else t.push(e)}flatten(){let e=new F;return this.flatten_t(this,e),e}getRegValue(e){return this.runner.getRegValue(e)}getOutputBuffer(){return this.runner.getOutputBuffer()}getPopback(e,t){let s=0;for(;e<t.length&&t[e]instanceof Y;)s+=parseInt(t[e].bytes),e++;return s}markPopBacks(e,t,s){for(;e<s.length&&s[e]instanceof Y;)t[e]=1,e++}removeUselessPushPopBlocks(e){let t=new F,s=new Array(e.length).fill(0);for(let i=0,r=e.length;i<r;i++)s[i]||(e[i]instanceof Y?t.push(new Y(this.getPopback(i,e))):t.push(e[i])),this.markPopBacks(i,s,e);return t}removeComplementaryPushPopBlocks(e){let t=new F,s=new Array(e.length).fill(0);for(let t=0,i=e.length-1;t<i;t++)e[t]instanceof X&&e[t+1]instanceof Y&&4==parseInt(e[t+1].bytes)?(s[t]=1,s[t+1]=1):e[t]instanceof X&&e[t+1]instanceof Y&&(s[t]=1,e[t+1].bytes=parseInt(e[t+1].bytes)-4);for(let i=0,r=e.length;i<r;i++)s[i]||t.push(e[i]);return t}optimize(){this.block=this.flatten().block;let e=this.removeUselessPushPopBlocks(this.block).block;this.block=this.removeComplementaryPushPopBlocks(e).block}run(){this.runner=new G(this.flatten().block),this.runner.run()}}class U{toString(){return"UNDEFINED REGISTER"}}const W={MEM_TO_REG:1,REG_TO_REG:2,REG_TO_MEM:3,NUMBER_TO_REG:4,STACK_TO_REG:5,REG_TO_STACK:6,REG_MEM_TO_REG:7,REG_TO_MEM_REG:8};class H extends U{constructor(e){super(),this.reg=e}toString(){return`SETDOR $${this.reg}`}}class K extends U{constructor(e,t,s){super(),this.dst=e,this.src=t,this.type=s}toString(){switch(this.type){case W.NUMBER_TO_REG:return`MOV $${this.dst} ${this.src}`;case W.REG_TO_REG:return`MOV $${this.dst} $${this.src}`;case W.MEM_TO_REG:return`MOV $${this.dst} [${this.src}]`;case W.STACK_TO_REG:return 0==this.src?`MOV $${this.dst} [$st]`:`MOV $${this.dst} [$st-${this.src}]`;case W.REG_MEM_TO_REG:return`MOV $${this.dst} [$${this.src}]`;case W.REG_TO_MEM_REG:return`MOV [$${this.dst}] $${this.src}`;case W.REG_TO_STACK:return 0==this.dst?`MOV [$st] $${this.src}`:`MOV [$st-${this.dst}] $${this.src}`}}}class j extends U{constructor(e,t,s){super(),this.dst=e,this.b=t,this.c=s}toString(){return`ADD $${this.dst} $${this.b} $${this.c}`}}class J extends U{constructor(e,t,s){super(),this.dst=e,this.b=t,this.c=s}toString(){return`SUB $${this.dst} $${this.b} $${this.c}`}}class q extends U{constructor(e,t,s){super(),this.dst=e,this.b=t,this.c=s}toString(){return`MUL $${this.dst} $${this.b} $${this.c}`}}class X extends U{constructor(e){super(),this.register=e}toString(){return`PUSH $${this.register}`}}class Y extends U{constructor(e,t=1){super(),this.bytes=e,this.type=t}toString(){switch(this.type){case 1:return`POP ${this.bytes}`;case 2:return`POP $${this.bytes}`}return""}}class Z extends U{constructor(e,t){super(),this.regA=e,this.regB=t}toString(){return`CMP $${this.regA} $${this.regB}`}}class Q extends U{constructor(e){super(),this.regA=e}toString(){return`SETNE $${this.regA}`}}class ee extends U{constructor(e){super(),this.regA=e}toString(){return`SETE $${this.regA}`}}class te extends U{constructor(e,t){super(),this.regA=e,this.regB=t}toString(){return`TEST $${this.regA} $${this.regB}`}}class se extends U{constructor(e){super(),this.regA=e}toString(){return`SETNZ $${this.regA}`}}class ie extends U{constructor(e,t){super(),this.regA=e,this.regB=t}toString(){return`OR $${this.regA} $${this.regB}`}}class re extends U{constructor(e){super(),this.regA=e}toString(){return`SETGE $${this.regA}`}}class ne extends U{constructor(e){super(),this.regA=e}toString(){return`SETLE $${this.regA}`}}class oe extends U{constructor(e){super(),this.label=e}toString(){return`JZ ${this.label}`}}class he extends U{constructor(e){super(),this.label=e}toString(){return`:${this.label}`}}const ae={LABEL:1,REGISTER:2};class le extends U{constructor(e,t=ae.LABEL){super(),this.value=e,this.type=t}toString(){switch(this.type){case ae.LABEL:return`JMP ${this.value}`;case ae.REGISTER:return`JMP $${this.value}`}}}class ce extends U{constructor(e,t){super(),this.a=e,this.b=t}toString(){return`DIV $${this.a} $${this.b}`}}class ue extends U{constructor(e,t){super(),this.reg=e,this.offset=t}toString(){return`PRP $${this.reg} ${this.offset}`}}const de={MEMORY:1,REGISTER:2};class ge extends U{constructor(e,t=de.REGISTER){super(),this.value=e,this.type=t}toString(){switch(this.type){case de.REGISTER:return`PRR $${this.value} 4`;case de.MEMORY:return`PRR [${this.value}] 4`}}}let pe=0;class fe{constructor(e){this.chomp=e,this.left=null,this.right=null,this.nodeID="expr-node-"+pe++,this.register=null}}class me{constructor(e){this.expressionChomp=e,this.root=null,this.precedence=[["&&","||"],["==","!=","<=",">=","<",">"],["^","&","|","<<",">>"],["+","-"],["*","/","%"]],this.returnType=1}toString_t(e){if(!e.left&&!e.right)return e.chomp.buffer;let t=this.toString_t(e.left),s=this.toString_t(e.right);return`(${t+e.chomp.buffer+s})`}toString(){return this.toString_t(this.root)}createNode(e,t,s){let i=new fe(s);return i.left=e,i.right=t,i}isNodeVariable(e){return e.chomp.type==c}isNodeMethodCall(e){return!(!e||!e.chomp)&&e.chomp.type==w}getExpressionRegister(e){return e.expressionTree.root.register}getRegister(e){return this.root.register}getNodeMethodCallRegisterResponse(e,t,s,i){const r=e.chomp.childrenChomps,n=r[0],o=r[1].childrenChomps,h=Date.now();s.freeze();for(let e=0,r=o.length;e<r;e++){const r=o[e];r.expressionTree.addInstructionToBlockWithOrder(t,i,s);const n=this.getExpressionRegister(r);t.push(new X(n)),i.freeRegister(n),s.push(`${h}_${e}`,4)}return s.push(`return_address_offset_${h}`,4),t.push(new ue("ret",3)),t.push(new X("ret")),t.push(new le(`_${n.buffer}`)),t.push(new Y(s.getFreezeTopDiff())),s.pop(),t.push(new X("rsp")),s.push(e.nodeID,4),"rsp"}getNodeValue(e,t,s,i){return this.isNodeMethodCall(e)?this.getNodeMethodCallRegisterResponse(e,t,s,i):this.isNodeVariable(e)?s.getStackOffset(e.chomp.buffer):e.chomp.buffer}getNodeMovType(e){return this.isNodeMethodCall(e)?W.REG_TO_REG:this.isNodeVariable(e)?W.STACK_TO_REG:W.NUMBER_TO_REG}findRegisterForNode(e,t){const s=t.isNodeIDUsed(e.nodeID);if(null!=s)return s;const i=t.findUnusedRegister();return t.saveRegisterID(i,e.nodeID),e.register=i,i}isLeaf(e){return!e.left&&!e.right}pushNonPointerNode(e,t,s,i){let r=this.findRegisterForNode(e,s);return t.push(new K(r,this.getNodeValue(e,t,i,s),this.getNodeMovType(e))),r}pushPointerNode(e,t,s,i){const r=e.chomp.childrenChomps[0];r.expressionTree.addInstructionToBlockWithOrder(t,s,i);let n=this.findRegisterForNode(e,s);const o=r.expressionTree.getRegister(s);return t.push(new K(n,o,W.REG_MEM_TO_REG)),n!=o&&s.freeRegister(o),n}pushLeafNode(e,t,s,i){return e.chomp.type===M?this.pushPointerNode(e,t,s,i):this.pushNonPointerNode(e,t,s,i)}pushMov(e,t,s,i){if(this.isLeaf(e))return this.pushLeafNode(e,t,s,i);let r=this.findRegisterForNode(e,s);return t.push(new K(r,i.getStackOffset(e.nodeID),W.STACK_TO_REG)),r}movAndGetFreeRegisters(e,t,s,i){let r=[null,null],n=[e.left,e.right];for(let e=0;e<n.length;e++){const o=n[e];this.isNodeMethodCall(o)&&(this.getNodeMethodCallRegisterResponse(o,t,i,s),r[e]=this.findRegisterForNode(o,s))}for(let e=0,o=r.length;e<o;e++)null==r[e]?r[e]=this.pushMov(n[e],t,s,i):t.push(new K(r[e],i.getStackOffset(n[e].nodeID),W.STACK_TO_REG));return r}freeRegisters(e,t){for(let s=0,i=e.length;s<i;s++)t.freeRegister(e[s])}addNodeToTheStack(e,t,s,i,r){s.push(new X(t)),i.push(e.nodeID,4),this.freeRegisters([t],r)}add_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),o=this.findRegisterForNode(e,s);t.push(new j(o,r,n)),this.addNodeToTheStack(e,o,t,i,s),this.freeRegisters([r,n],s)}sub_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),o=this.findRegisterForNode(e,s);t.push(new J(o,r,n)),this.addNodeToTheStack(e,o,t,i,s),this.freeRegisters([r,n],s)}mul_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),o=this.findRegisterForNode(e,s);t.push(new q(o,r,n)),this.addNodeToTheStack(e,o,t,i,s),this.freeRegisters([r,n],s)}div_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new ce(r,n)),this.freeRegisters([r,n],s);let o=this.findRegisterForNode(e,s);t.push(new K(o,"LO",W.REG_TO_REG)),this.addNodeToTheStack(e,o,t,i,s)}reminder_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new ce(r,n)),this.freeRegisters([r,n],s);let o=this.findRegisterForNode(e,s);t.push(new K(o,"HI",W.REG_TO_REG)),this.addNodeToTheStack(e,o,t,i,s)}equal_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new Z(r,n)),this.freeRegisters([r,n],s);let o=this.findRegisterForNode(e,s);t.push(new ee(o)),this.addNodeToTheStack(e,o,t,i,s)}setGe_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new Z(r,n)),this.freeRegisters([r,n],s);let o=this.findRegisterForNode(e,s);t.push(new re(o)),this.addNodeToTheStack(e,o,t,i,s)}setLe_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new Z(r,n)),this.freeRegisters([r,n],s);let o=this.findRegisterForNode(e,s);t.push(new ne(o)),this.addNodeToTheStack(e,o,t,i,s)}notEqual_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new Z(r,n)),this.freeRegisters([r,n],s);let o=this.findRegisterForNode(e,s);t.push(new Q(o)),this.addNodeToTheStack(e,o,t,i,s)}less_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new Z(r,n)),this.freeRegisters([r,n],s);let o=this.findRegisterForNode(e,s);t.push(new K(o,"CF",W.REG_TO_REG)),this.addNodeToTheStack(e,o,t,i,s)}more_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new Z(r,n)),this.freeRegisters([r,n],s);let o=this.findRegisterForNode(e,s);t.push(new K(o,"CT",W.REG_TO_REG)),this.addNodeToTheStack(e,o,t,i,s)}doubleAnd_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new Z(r,n)),this.freeRegisters([r,n],s);let o=this.findRegisterForNode(e,s);t.push(new se(o)),this.addNodeToTheStack(e,o,t,i,s)}doubleOr_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),o=this.findRegisterForNode(e,s);t.push(new ie(r,n)),t.push(new H(o)),this.addNodeToTheStack(e,o,t,i,s),this.freeRegisters([r,n],s)}addInstructions(e,t,s,i){switch(e.chomp.buffer){case"+":this.add_InstructionSet(e,t,s,i);break;case"-":this.sub_InstructionSet(e,t,s,i);break;case"*":this.mul_InstructionSet(e,t,s,i);break;case"==":this.equal_InstructionSet(e,t,s,i);break;case"<":this.less_InstructionSet(e,t,s,i);break;case">":this.more_InstructionSet(e,t,s,i);break;case"!=":this.notEqual_InstructionSet(e,t,s,i);break;case"&&":this.doubleAnd_InstructionSet(e,t,s,i);break;case"||":this.doubleOr_InstructionSet(e,t,s,i);break;case">=":this.setGe_InstructionSet(e,t,s,i);break;case"<=":this.setLe_InstructionSet(e,t,s,i);break;case"/":this.div_InstructionSet(e,t,s,i);break;case"%":this.reminder_InstructionSet(e,t,s,i)}}addInstructionToBlock_t(e,t,s,i){(e.left||e.right)&&(this.addInstructionToBlock_t(e.left,t,s,i),this.addInstructionToBlock_t(e.right,t,s,i),this.addInstructions(e,t,s,i))}addInstructionToBlock(e,t,s){if(this.root.left||this.root.right)this.addInstructionToBlock_t(this.root,e,t,s);else{let i=this.findRegisterForNode(this.root,t);e.push(new K(i,this.getNodeValue(this.root,e,s,t),this.getNodeMovType(this.root)))}}expressionRoot(e){let t=new me(e);return t.build(),t.root}isOperationLeaf(e){return!this.isLeaf(e)&&this.isLeaf(e.left)&&this.isLeaf(e.right)}numberOfOperations(e){return e?this.numberOfOperations(e.left)+this.numberOfOperations(e.right)+1:0}isVisited(e,t){return e.nodeID in t}order_t(e,t,s){if(!this.isVisited(e,t)&&!this.isLeaf(e)){if(this.isOperationLeaf(e))return s.push(e.left),s.push(e.right),s.push(e),t[e.left.nodeID]=1,t[e.right.nodeID]=1,void(t[e.nodeID]=1);if(this.isVisited(e.left,t)&&this.isVisited(e.right,t))return t[e.nodeID]=1,void s.push(e);if(this.isVisited(e.left,t)&&this.isLeaf(e.right))return t[e.nodeID]=1,t[e.right.nodeID]=1,s.push(e.right),void s.push(e);if(this.isVisited(e.right,t)&&this.isLeaf(e.left))return t[e.nodeID]=1,t[e.left.nodeID]=1,s.push(e.left),void s.push(e);this.order_t(e.left,t,s),this.order_t(e.right,t,s)}}order(){let e={},t=[],s=this.numberOfOperations(this.root);const i=this.root;if(this.isLeaf(i))return[i];for(;t.length<s;)this.order_t(i,e,t);return t}addResultToStack(e,t,s){if(2==this.returnType){const i=this.getRegister(t);e.push(new X(i)),s.push(this.root.nodeID,4),this.freeRegisters([i],t)}}pushLastNode(e,t,s){this.pushMov(this.root,e,t,s);let i=this.findRegisterForNode(this.root,t);e.push(new X(i)),s.push(this.root.nodeID,4),e.push(new Y(s.getFreezeTopDiff())),s.pop(),this.addResultToStack(e,t,s),this.freeRegisters([i],t)}addInstructionToBlockWithOrder(e,t,s,i=1){if(s.freeze(),this.returnType=i,!this.root.left&&!this.root.right)return void this.pushLastNode(e,t,s);const r=this.order();for(let i=0,n=r.length;i<n;i++)this.addInstructions(r[i],e,t,s);e.push(new Y(s.getFreezeTopDiff())),s.pop(),this.addResultToStack(e,t,s)}build_t(e=0,t){let s=this.expressionChomp.childrenChomps;if(e>=this.precedence.length)return s[t[0]].type==V?this.expressionRoot(s[t[0]]):new fe(s[t[0]]);let i=this.build_t(e+1,t);for(;t[0]+1<s.length;){const r=s[t[0]+1];let n=!1;for(let s=0,o=this.precedence[e].length;s<o;s++)if(this.precedence[e][s]==r.buffer){t[0]+=2;const s=this.build_t(e+1,t);i=this.createNode(i,s,r),n=!0}if(!n)break}return i}build(){this.root=this.build_t(0,[0])}}class be{constructor(){this.registerToID={},this.maxRegisters=32,this.IDToRegisters={}}findUnusedRegister(){for(let e=0;e<this.maxRegisters;e++)if(!(e in this.registerToID))return e;return null}getUsedRegisters(){let e=[];for(const[t,s]of Object.entries(this.registerToID))e.push(t);return e}registerFromID(e){return this.IDToRegisters[e]}isNodeIDUsed(e){return e in this.IDToRegisters?this.IDToRegisters[e]:null}saveRegisterID(e,t){this.registerToID[e]=t,this.IDToRegisters[t]=e}getRegisterFromID(e){return this.registerWithNodeID[e]}freeRegister(e){this.registerToID[e]in this.IDToRegisters&&delete this.IDToRegisters[this.registerToID[e]],e in this.registerToID&&delete this.registerToID[e]}}class Re{constructor(){this.stackValues=[],this.offset={},this.stackOffset=[],this.freezeHistory=[0],this.variableNames=[],this.freezeChunks=[0],this.methodFreezeChunk=0}getStackLastIndex(){return this.stackOffset.length?this.stackOffset[this.stackOffset.length-1]:0}push(e,t){this.offset[e]={stack_offset:this.getStackLastIndex(),size:t},this.stackOffset.push(this.getStackLastIndex()+t),this.variableNames.push(e)}freezeMethodPointer(){this.methodFreezeChunk=this.getStackLastIndex()}freeze(){this.freezeChunks.push(this.stackOffset.length),this.freezeHistory.push(this.getStackLastIndex())}topVariableName(){return this.variableNames.length?this.variableNames[this.variableNames.length-1]:null}pop(){if(this.freezeHistory.length){for(let e=this.stackOffset.length-1;e>=this.freezeChunks[this.freezeChunks.length-1];e--){this.stackOffset.pop();const e=this.topVariableName();delete this.offset[e],this.variableNames.pop()}this.freezeHistory.pop(),this.freezeChunks.pop()}}getFreezeTopDiff(){return this.freezeHistory.length?this.getStackLastIndex()-this.freezeHistory[this.freezeHistory.length-1]:this.getStackLastIndex()}getFreezeTopDiffFromMethod(){return this.getStackLastIndex()-this.methodFreezeChunk}getStackOffset(e){return e in this.offset?this.getStackLastIndex()-this.offset[e].stack_offset:null}}class Ie{constructor(e){this.ast=e,this.registerMem=new be,this.registerStack=new Re,this.globalStack=new Re,this.labelID=0,this.assignationID=0}buildExpressionTrees(e){let t=m.searchChompByType(e,{type:V});for(let e=0,s=t.length;e<s;e++){let s=new me(t[e]);t[e].expressionTree||(s.build(),t[e].expressionTree=s)}}createExpressionAsm(e,t,s=1){e.expressionTree.addInstructionToBlockWithOrder(t,this.registerMem,this.registerStack,s)}saveExpressionResult(e,t){const s=e.expressionTree.root.register;t.push(new X(s)),this.registerMem.freeRegister(s)}loadVariableInStack(e,t,s){this.createExpressionAsm(e,s);const i=this.getExpressionRegister(e),r=this.registerStack.getStackOffset(t.buffer);s.push(new K(r,i,W.REG_TO_STACK)),this.registerMem.freeRegister(i)}getExpressionStackPoint(e){return this.registerStack.getStackOffset(e.expressionTree.root.nodeID)}loadPointerInStack(e,t,s){this.registerStack.freeze(),this.createExpressionAsm(e,s,2),this.createExpressionAsm(t,s,2);let i=this.registerMem.findUnusedRegister();this.registerMem.saveRegisterID(i,"assignation-id-"+this.assignationID++);let r=this.registerMem.findUnusedRegister();this.registerMem.saveRegisterID(r,"assignation-id-"+this.assignationID++),s.push(new K(r,this.getExpressionStackPoint(t),W.STACK_TO_REG)),s.push(new K(i,this.getExpressionStackPoint(e),W.STACK_TO_REG)),s.push(new K(r,i,W.REG_TO_MEM_REG)),s.push(new Y(this.registerStack.getFreezeTopDiff())),this.registerMem.freeRegister(i),this.registerMem.freeRegister(r),this.registerStack.pop()}loadExpressionOnStack(e,t,s){t.type===M?this.loadPointerInStack(e,t.childrenChomps[0],s):this.loadVariableInStack(e,t,s)}compileInitialization(e,t=this.registerStack){const s=e.childrenChomps;let i=new F;for(let e=1,t=s.length;e<t;e++){const t=s[e],r=t.childrenChomps[0],n=t.childrenChomps[1];this.createExpressionAsm(n,i),this.registerStack.push(r.buffer,4),this.saveExpressionResult(n,i)}return i}compileAssignation(e){const t=e.childrenChomps;let s=new F;const i=t[1],r=t[0];return this.loadExpressionOnStack(i,r,s),s}popStackValues(e){const t=this.registerStack.getFreezeTopDiff();t&&e.push(new Y(t))}getExpressionRegister(e){return e.expressionTree.root.register}nextLabel(){return this.labelID++}compileWhile(e){let t=new F;const s=e.childrenChomps;let i=s[0],r=s[1];const n=`_label${this.nextLabel()}`;t.push(new he(n)),this.createExpressionAsm(i,t);const o=this.getExpressionRegister(i),h=`_label${this.nextLabel()}`;return t.push(new te(o,o)),this.registerMem.freeRegister(o),t.push(new oe(h)),t.push(this.compileBlock(r)),t.push(new le(n)),t.push(new he(h)),t}compileFor(e){let t=new F;const s=e.childrenChomps;let i=s[0],r=s[1],n=s[2],o=s[3];switch(this.registerStack.freeze(),t.push(new he(`_startForLoop${this.nextLabel()}`)),i.type){case I:t.push(this.compileInitialization(i));break;case f:t.push(this.compileAssignation(i))}const h=`_label${this.nextLabel()}`;t.push(new he(h)),this.createExpressionAsm(r,t);const a=this.getExpressionRegister(r),l=`_label${this.nextLabel()}`;return t.push(new te(a,a)),this.registerMem.freeRegister(a),t.push(new oe(l)),t.push(this.compileBlock(o)),t.push(this.compileAssignation(n)),t.push(new le(h)),t.push(new he(l)),t.push(new Y(this.registerStack.getFreezeTopDiff())),this.registerStack.pop(),t}compileLoop(e){switch(e.buffer){case"while":return this.compileWhile(e);case"for":return this.compileFor(e)}return new F}popReturnStackPointer(e){const t=this.registerStack.getFreezeTopDiffFromMethod();t&&e.push(new Y(t))}compileReturnNonVoidMethod(e){const t=e.childrenChomps[0];let s=new F;this.createExpressionAsm(t,s);const i=this.getExpressionRegister(t);return s.push(new K("ret",this.registerStack.getStackOffset("return_address"),W.STACK_TO_REG)),s.push(new K("rsp",i,W.REG_TO_REG)),this.popReturnStackPointer(s),s.push(new le("ret",ae.REGISTER)),this.registerMem.freeRegister(i),s}compileReturnVoidMethod(e){let t=new F;return t.push(new K("ret",this.registerStack.getStackOffset("return_address"),W.STACK_TO_REG)),this.popReturnStackPointer(t),t.push(new le("ret",ae.REGISTER)),t}compileConditionalBlock(e){let t=new F;const s=e.childrenChomps,i=s[0],r=s[1];this.createExpressionAsm(i,t);const n=this.getExpressionRegister(i),o=`_label${this.nextLabel()}`;return t.push(new te(n,n)),this.registerMem.freeRegister(n),t.push(new oe(o)),t.push(this.compileBlock(r)),t.push(new he(o)),t}compileExpression(e){let t=new F;return this.createExpressionAsm(e,t),t}compileBlock(e,t=!0){let s=new F;this.buildExpressionTrees(e);const i=e.childrenChomps;this.registerStack.freeze();for(let e=0,t=i.length;e<t;e++){const t=i[e];switch(t.type){case f:s.push(this.compileAssignation(t));break;case I:s.push(this.compileInitialization(t));break;case T:s.push(this.compileBlock(t));break;case S:s.push(this.compileLoop(t));break;case E:s.push(this.compileReturnNonVoidMethod(t));break;case C:s.push(this.compileReturnVoidMethod(t));break;case y:s.push(this.compileConditionalBlock(t));break;case V:s.push(this.compileExpression(t))}}return t&&this.popStackValues(s),this.registerStack.pop(),s}isMethodMain(e){return"main"==e.buffer}compileMainMethod(e,t){let s=new F;const i=`_${e}`;return s.push(new he(i)),s.push(this.compileBlock(t)),s}compileMethods(e){const t=e.childrenChomps;let s=new F;const i=t[0],r=t[1].childrenChomps,n=t[2],o=i.childrenChomps[1];if(this.isMethodMain(o))return this.compileMainMethod(o.buffer,n);const h=`_${o}`;s.push(new he(h)),this.registerStack.freeze();for(let e=0;e<r.length;e++){const t=r[e].childrenChomps[1];this.registerStack.push(t.buffer,4)}return this.registerStack.push("return_address",4),this.registerStack.freezeMethodPointer(),s.push(this.compileBlock(n,!1)),this.registerStack.pop(),s}compileProgram(e,t=!0){let s=e.childrenChomps;this.buildExpressionTrees(e);let i=new F;i.push(new le("_main"));for(let e=0,t=s.length;e<t;e++){const t=s[e];t.type===D&&(t.ignore||i.push(this.compileMethods(t)))}return t&&i.optimize(),i}}class ke{constructor(e,t={zeroReg:31,stackPointerRegister:30,stddoutRegister:29,freeRegister:28,hi:27,lo:26,testRegister:25,rsp:24,ret:23,bitSplitterRegister:22},s=1048576){this.block=e,this.stackPointerRegister=t.stackPointerRegister,this.stddoutRegister=t.stddoutRegister,this.memorySize=s,this.hi=t.hi,this.lo=t.lo,this.registerData=t,this.memory=new Array(this.memorySize).fill(0),this.register=new Array(40).fill(0),this.pc=0}getRawStdoutBuffer(){let e=this.registerValue(this.stddoutRegister);const t=this.getNumberAtAddress(this.memory,e-4);let s="";for(let i=0;i<t;i++)s+=String.fromCharCode(this.memory[i+e]);return s}getStackPointer(){return this.registerValue(this.stddoutRegister)}registerValue(e){return this.register[parseInt(e)]}printPointerBytes(e,t){let s=[];for(let i=0;i<e;i++)s.push(this.memory[t+i]);return s}printStack(e){let t=[],s=this.registerValue(this.stackPointerRegister);for(let i=0;i<e;i++)t.push(this.memory[s+i]);return t.join(" ")}unsigned(e){return e>=0?e:2**32- -(e+1)}positiveNumberToByteArray(e){const t=[0,0,0,0];return t[0]=255&e,t[1]=e>>8&255,t[2]=e>>16&255,t[3]=e>>24&255,t}negativeNumberToByteArray(e){const t=2**32+e;return this.positiveNumberToByteArray(t)}numberToByteArray(e){return e>=0?this.positiveNumberToByteArray(e):this.negativeNumberToByteArray(e)}saveRegInMemory(e,t,s){let i=this.numberToByteArray(this.registerValue(t));for(let t=0,r=i.length;t<r;t++)this.memory[e+t+s]=i[t]}get32ByteInteger(e){return e<2**31?e:-(2**32-e)}getNumberAtAddress(e,t,s=1){switch(s){case 1:{let s=0,i=1;for(let r=0;r<4;r++)s+=e[t+r]*i,i*=256;return this.get32ByteInteger(s)}case 2:return e[t]}return 0}saveNumberInReg(e,t,s){let i=this.getNumberAtAddress(this.memory,e+s);this.register[parseInt(t)]=i}runInstruction(e){e instanceof ye&&(this.register[parseInt(e.dst)]=this.registerValue(e.srcA)+this.registerValue(e.srcB)),e instanceof Ee&&(this.register[parseInt(e.d)]=this.registerValue(e.s)-this.registerValue(e.t)),e instanceof De&&(this.register[parseInt(e.d)]=this.registerValue(e.s)|this.registerValue(e.t)),e instanceof Me&&(this.register[parseInt(e.d)]=this.registerValue(e.s)&this.registerValue(e.t)),e instanceof Ae&&(this.register[this.lo]=Math.floor(this.registerValue(e.s)/this.registerValue(e.t)),this.register[this.hi]=this.registerValue(e.s)%this.registerValue(e.t)),e instanceof Ge&&(this.pc=parseInt(e.register)),e instanceof Pe&&this.registerValue(e.s)==this.registerValue(e.t)&&(this.pc+=parseInt(e.label)),e instanceof Te&&(this.register[parseInt(e.t)]=this.registerValue(e.s)+parseInt(e.immediate)),e instanceof Oe&&(this.pc=this.registerValue(e.register)),e instanceof we&&(this.register[this.lo]=this.registerValue(e.s)*this.registerValue(e.t)),e instanceof Be&&(this.register[parseInt(e.d)]=this.booleanToNumber(this.registerValue(e.s)<this.registerValue(e.t))),e instanceof Ue&&(this.register[parseInt(e.d)]=this.booleanToNumber(this.unsigned(this.registerValue(e.s))<this.unsigned(this.registerValue(e.t)))),e instanceof $e&&(this.register[parseInt(e.d)]=this.registerValue(e.s)^this.registerValue(e.t)),e instanceof Ve&&(this.register[parseInt(e.d)]=this.registerValue(e.s)^parseInt(e.i)),e instanceof Ce&&this.saveRegInMemory(this.registerValue(e.s),e.t,parseInt(e.i)),e instanceof Ne&&this.saveNumberInReg(this.registerValue(e.s),e.t,parseInt(e.i)),e instanceof xe&&(this.register[parseInt(e.d)]=this.registerValue(e.s)&parseInt(e.i)),e instanceof _e&&(this.register[parseInt(e.s)]=this.registerValue(e.t)<<parseInt(e.i))}booleanToNumber(e){return e?1:0}run(){for(this.pc=0;this.pc<this.block.length;this.pc++)this.runInstruction(this.block[this.pc])}}class Se{constructor(e,t,s,i=!0,r={zeroReg:31,stackPointerRegister:30,stddoutRegister:29,freeRegister:28,hi:27,lo:26,testRegister:25,rsp:24,ret:23,bitSplitterRegister:22},n=1048576){this.registerBlock=e.flatten(),this.registerBlock.optimize(),this.stddout=t,this.stackPointer=s,this.block=[],this.memorySize=n,this.registerData=r,this.registerCount=32,this.usedRegisters={HI:this.registerData.hi,LO:this.registerData.lo,rsp:this.registerData.rsp,ret:this.registerData.ret},this.labelsOffsets={},i&&(this.prepareHeader(),this.iterateBlock(),this.iterateImediates(),this.createLabelOffsets())}iterateImediates(){let e=[];for(let t=0,s=this.block.length;t<s;t++)this.block[t]instanceof Te?this.addNumberToBlock(this.block[t],e):e.push(this.block[t]);this.block=e}getStdoutResponse(){let e=[];for(let t=0,s=this.runner.getNumberAtAddress(this.runner.memory,this.stddout-4);t<s;t+=4)e.push(this.getNumberAtAddress(this.runner.memory,this.stddout+t));return e.join("\n")}addLabelFromImmediate(e,t){if(this.doesNumberFitInImmediate(e.register))return void t.push(e);let s=parseInt(e.register),i=65535&s,r=s>>16;t.push(new Te(this.registerData.bitSplitterRegister,this.registerData.zeroReg,i)),t.push(new Te(this.registerData.freeRegister,this.registerData.zeroReg,r)),t.push(new _e(this.registerData.freeRegister,this.registerData.freeRegister,16)),t.push(new De(this.registerData.freeRegister,this.registerData.freeRegister,this.registerData.bitSplitterRegister)),t.push(new Oe(this.registerData.freeRegister))}rebuildJumpInstructions(){let e=[];for(let t=0,s=this.block.length;t<s;t++)this.block[t]instanceof Ge?this.addLabelFromImmediate(this.block[t],e):e.push(this.block[t]);this.block=e}createLabelOffsets(){for(let e=0,t=this.block.length;e<t;e++)this.block[e]instanceof Le&&(this.labelsOffsets[this.block[e].label]=e,this.block[e]=new ze);for(let e=0,t=this.block.length;e<t;e++)this.block[e]instanceof Ge&&(this.block[e]=new Ge(this.labelsOffsets[this.block[e].register])),this.block[e]instanceof Pe&&(this.block[e].label=this.labelsOffsets[this.block[e].label]-e),this.block[e]instanceof Fe&&(this.block[e]=new Te(this.getRegisterValue(this.block[e].reg),this.registerData.zeroReg,e+this.block[e].offset))}numberToUnsignedRpresentation(e){return e>=0?e:2**32-e+1}doesNumberFitInImmediate(e){return parseInt(e)<65536}iterateBlock(){const e=this.registerBlock.block;for(let t=0,s=e.length;t<s;t++){const s=e[t];s instanceof K&&this.addMoveBlock(s,e,t),s instanceof X&&this.addPushBlock(s),s instanceof j&&this.addAddInstruction(s),s instanceof Y&&this.addPopInstruction(s),s instanceof q&&this.addMultInstruction(s),s instanceof ce&&this.addDivInstruction(s),s instanceof le&&this.addJumpInstruction(s),s instanceof he&&this.block.push(new Le(s.label)),s instanceof Z||(s instanceof Q&&this.addSetneInstruction(s,e,t),s instanceof ee&&this.addSeteInstruction(s,e,t),s instanceof re&&this.addSetgeInstruction(s,e,t),s instanceof ne&&this.addSetleInstruction(s,e,t),s instanceof se&&this.addSetnzInstruction(s,e,t),s instanceof H&&this.addSetdorInstruction(s,e,t),s instanceof J&&this.addSubInstruction(s),s instanceof te&&this.addSetTestInstruction(s,e,t),s instanceof oe&&this.addJzInstruction(s),s instanceof ue&&this.addPrpInstruction(s))}}addPrpInstruction(e){this.block.push(new Fe(e.reg,e.offset))}addJzInstruction(e){this.block.push(new Pe(this.registerData.testRegister,this.registerData.zeroReg,e.label))}addSetTestOnEqual(e){this.block.push(new Ue(this.registerData.testRegister,this.registerData.zeroReg,e.regA))}addSetTestInstruction(e){e.regA!=e.regB?(this.block.push(new Be(e.regA,this.registerData.zeroReg,e.regA)),this.block.push(new Be(e.regB,this.registerData.zeroReg,e.regB)),this.block.push(new Me(this.registerData.testRegister,e.regA,e.regB))):this.addSetTestOnEqual(e)}addSubInstruction(e){this.block.push(new Ee(e.dst,e.b,e.c))}addSetdorInstruction(e,t,s){let i=this.searchClosestOr(t,s);this.block.push(new Ue(i.regA,this.registerData.zeroReg,i.regA)),this.block.push(new Ue(i.regB,this.registerData.zeroReg,i.regB)),this.block.push(new De(e.reg,i.regA,i.regB))}addSetnzInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new Ue(i.regA,this.registerData.zeroReg,i.regA)),this.block.push(new Ue(i.regB,this.registerData.zeroReg,i.regB)),this.block.push(new Me(e.regA,i.regA,i.regB))}addSetleInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new Be(e.regA,i.regB,i.regA)),this.block.push(new Ve(e.regA,e.regA,1))}addSetgeInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new Be(e.regA,i.regA,i.regB)),this.block.push(new Ve(e.regA,e.regA,1))}addSeteInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new $e(i.regA,i.regA,i.regB)),this.block.push(new Ue(e.regA,this.registerData.zeroReg,i.regA)),this.block.push(new Ve(e.regA,e.regA,1))}addSetneInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new $e(i.regA,i.regA,i.regB)),this.block.push(new Ue(e.regA,this.registerData.zeroReg,i.regA))}addJumpInstruction(e){switch(e.type){case ae.REGISTER:this.block.push(new Oe(this.getRegisterValue(e.value)));break;case ae.LABEL:this.block.push(new Ge(e.value))}}getRegisterValue(e){return e in this.usedRegisters?this.usedRegisters[e]:e}addDivInstruction(e){this.block.push(new Ae(e.a,e.b))}addMultInstruction(e){this.block.push(new we(e.b,e.c)),this.block.push(new Te(e.dst,this.registerData.lo,0))}addPushBlock(e){this.block.push(new Ce(this.getRegisterValue(e.register),0,this.registerData.stackPointerRegister)),this.block.push(new Te(this.registerData.stackPointerRegister,this.registerData.stackPointerRegister,4))}addAddInstruction(e){this.block.push(new ye(e.dst,e.b,e.c))}addPopInstruction(e){this.block.push(new Te(this.registerData.freeRegister,this.registerData.zeroReg,e.bytes)),this.block.push(new Ee(this.registerData.stackPointerRegister,this.registerData.stackPointerRegister,this.registerData.freeRegister))}searchClosestCmp(e,t){for(let s=t;s>=0;s--)if(e[s]instanceof Z)return e[s];return null}searchClosestOr(e,t){for(let s=t;s>=0;s--)if(e[s]instanceof ie)return e[s];return null}addSpecialMov(e,t,s){let i=this.searchClosestCmp(t,s);"CF"!=e.src?"CT"!=e.src?this.block.push(new ye(this.getRegisterValue(e.dst),this.getRegisterValue(e.src),this.registerData.zeroReg)):this.block.push(new Be(e.dst,i.regB,i.regA)):this.block.push(new Be(e.dst,i.regA,i.regB))}addNumberToBlock(e,t){let s=e.t;if(this.doesNumberFitInImmediate(e.immediate))return void t.push(e);let i=parseInt(e.immediate),r=65535&i,n=i>>16;t.push(new Te(this.registerData.bitSplitterRegister,this.registerData.zeroReg,r)),t.push(new Te(s,this.registerData.zeroReg,n)),t.push(new _e(s,s,16)),t.push(new De(s,s,this.registerData.bitSplitterRegister))}getPositiveLwInstructions(e,t,s){return t>=0?new Ne(e,t,s):(this.block.push(new Te(this.registerData.freeRegister,this.registerData.zeroReg,-t)),this.block.push(new Ee(this.registerData.freeRegister,s,this.registerData.freeRegister)),new Ne(e,0,this.registerData.freeRegister))}getPositiveSwInstructions(e,t,s){return t>=0?new Ce(e,t,s):(this.block.push(new Te(this.registerData.freeRegister,this.registerData.zeroReg,-t)),this.block.push(new Ee(this.registerData.freeRegister,s,this.registerData.freeRegister)),new Ce(e,0,this.registerData.freeRegister))}addMoveBlock(e,t,s){switch(e.type){case W.REG_TO_REG:this.addSpecialMov(e,t,s);break;case W.NUMBER_TO_REG:this.block.push(new Te(this.getRegisterValue(e.dst),this.registerData.zeroReg,e.src));break;case W.STACK_TO_REG:this.block.push(this.getPositiveLwInstructions(this.getRegisterValue(e.dst),-e.src,this.registerData.stackPointerRegister));break;case W.REG_TO_STACK:this.block.push(this.getPositiveSwInstructions(this.getRegisterValue(e.src),-e.dst,this.registerData.stackPointerRegister));break;case W.REG_MEM_TO_REG:this.block.push(this.getPositiveLwInstructions(this.getRegisterValue(e.dst),0,this.getRegisterValue(e.src)));break;case W.REG_TO_MEM_REG:this.block.push(this.getPositiveSwInstructions(this.getRegisterValue(e.src),0,this.getRegisterValue(e.dst)))}}prepareHeader(){this.block.push(new De(this.registerData.zeroReg,this.registerData.zeroReg,this.registerData.zeroReg)),this.block.push(new Te(this.registerData.stackPointerRegister,this.registerData.zeroReg,this.stackPointer)),this.block.push(new Te(this.registerData.stddoutRegister,this.registerData.zeroReg,this.stddout))}run(){this.runner=new ke(this.block,this.registerData,this.memorySize),this.runner.run()}toString_t(e=!1){let t=[];for(let s=0,i=this.block.length;s<i;s++)e?t.push(`${s}: ${this.block[s].toString()}`):t.push(this.block[s].toString());return t.join("\n")}toString(e=!1){return this.flatten().toString_t(e)}flatten_t(e,t){if(e instanceof Se)for(let s=0,i=e.block.length;s<i;s++)this.flatten_t(e.block[s],t);else t.push(e)}flatten(){let e=new Se(this.registerBlock,this.stddout,this.stackPointer,!1);return this.flatten_t(this,e),e}push(e){this.block.push(e)}}class ve{toString(){return"UNDEFINED REGISTER"}}class ye extends ve{constructor(e,t,s){super(),this.dst=e,this.srcA=t,this.srcB=s}toString(){return`ADD $${this.dst} $${this.srcA} $${this.srcB}`}}class Te extends ve{constructor(e,t,s){super(),this.t=e,this.s=t,this.immediate=s}toString(){return`ADDI $${this.t} $${this.s} ${this.immediate}`}}class Ae extends ve{constructor(e,t){super(),this.s=e,this.t=t}toString(){return`DIV $${this.s} $${this.t}`}}class we extends ve{constructor(e,t){super(),this.s=e,this.t=t}toString(){return`MULT $${this.s} $${this.t}`}}class _e extends ve{constructor(e,t,s){super(),this.s=e,this.t=t,this.i=s}toString(){return`SLL $${this.s} $${this.t} ${this.i}`}}class Ee extends ve{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`SUB $${this.d} $${this.s} $${this.t}`}}class Ce extends ve{constructor(e,t,s){super(),this.t=e,this.i=t,this.s=s}toString(){return`SW $${this.t} ${this.i}($${this.s})`}}class Ne extends ve{constructor(e,t,s){super(),this.t=e,this.i=t,this.s=s}toString(){return`LW $${this.t} ${this.i}($${this.s})`}}class De extends ve{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`OR $${this.d} $${this.s} $${this.t}`}}class $e extends ve{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`XOR $${this.d} $${this.s} $${this.t}`}}class Ve extends ve{constructor(e,t,s){super(),this.d=e,this.s=t,this.i=s}toString(){return`XORI $${this.d} $${this.s} ${this.i}`}}class Me extends ve{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`AND $${this.d} $${this.s} $${this.t}`}}class xe extends ve{constructor(e,t,s){super(),this.d=e,this.s=t,this.i=s}toString(){return`ANDI $${this.d} $${this.s} ${this.i}`}}class Oe extends ve{constructor(e){super(),this.register=e}toString(){return`JR $${this.register}`}}class Be extends ve{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`SLT $${this.d} $${this.s} $${this.t}`}}class Pe extends ve{constructor(e,t,s){super(),this.s=e,this.t=t,this.label=s}toString(){return`BEQ $${this.s} $${this.t} ${this.label}`}}class ze extends ve{constructor(){super()}toString(){return"NOOP"}}class Le extends ve{constructor(e){super(),this.label=e}toString(){return`:${this.label}`}}class Ge extends ve{constructor(e){super(),this.register=e}toString(){return`J ${this.register}`}}class Fe extends ve{constructor(e,t){super(),this.reg=e,this.offset=t}toString(){return`PRP $${this.reg} ${this.offset}`}}class Ue extends ve{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`SLTU $${this.d} $${this.s} $${this.t}`}}class We{constructor(e,t={}){this.code=e,this.config={},this.defaultConfig(),this.setNewConfig(t),this.mips32Instructions=null,this.intermediaryASMInsturctions=null}setNewConfig(e){for(const[t,s]of Object.entries(e))t in this.config&&(this.config[t]=s)}defaultConfig(){this.config.registerData={zeroReg:31,stackPointerRegister:30,stddoutRegister:29,freeRegister:28,hi:27,lo:26,testRegister:25,rsp:24,ret:23,bitSplitterRegister:22},this.config.stdout=256,this.config.stackPointer=524288,this.config.memorySize=1048576}compile(){const e=new L(this.code,[],!0,this.config.stdout);let t=e.chomp();if(t.isInvalid())throw new Error(`Errors: ${e.errorsToString()}`);let s=new Ie(null);return this.intermediaryASMInsturctions=s.compileProgram(t),this.mips32Instructions=new Se(this.intermediaryASMInsturctions,this.config.stdout,this.config.stackPointer,!0,this.config.registerData,this.config.memorySize),!0}mips32Code(){return this.mips32Instructions}intermediaryAsm(){return this.intermediaryASMInsturctions}stdoutBuffer(){return this.mips32Instructions.runner.getRawStdoutBuffer()}run(){return!!this.mips32Instructions&&(this.mips32Instructions.run(),!0)}}e.exports=s})()}},t={};function s(i){var r=t[i];if(void 0!==r)return r.exports;var n=t[i]={exports:{}};return e[i](n,n.exports,s),n.exports}s.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return s.d(t,{a:t}),t},s.d=(e,t)=>{for(var i in t)s.o(t,i)&&!s.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";var e=s(547);const t=document.getElementById("runButton"),i=document.getElementById("compileButton");t.addEventListener("click",(()=>{const t=document.getElementById("textarea1").value;let s=new e.Mips32Compiler(t,{stdout:524288,stackPointer:1048576,memorySize:4194304});s.compile(),s.run(),document.getElementById("textarea2").value=s.stdoutBuffer()})),i.addEventListener("click",(()=>{const e=document.getElementById("textarea1").value;console.log("Compiling code:",e),document.getElementById("textarea2").value=document.getElementById("textarea1").value}))})()})();